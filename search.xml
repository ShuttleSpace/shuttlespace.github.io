<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GraphQL-Scalars]]></title>
    <url>%2F2019%2F05%2F05%2FGraphQL-Scalars%2F</url>
    <content type="text"><![CDATA[graphql 中的常量scalarsgraphql 类型系统的叶子节点被称为 scalars.一旦到达了 scalar 类型则无法在沿着类型结构继续向下了.scalar 类型是指不可再分割的值.graphql 规范明确要求所有的语言实现必须具有以下 scalar 类型. String 即 GraphQLString- 一个 UTF-8 字符串序列. Boolean 即 GraphQLBoolean- true or false. Int 即 GraphQLInt- 有符号的 32 整型数. Float 即 GraphQLFloat- 有符号的双精度浮点数. ID 即 GraphQLID- 类似于 String 的唯一标识符.定义一个 ID 标识符即表示该属性不是人类可识别的用途.graphql-java 为 java 系统添加了以下有用的 scalar 类型. Long 即 GraphQLLong- 基于 java.lang.Long 的 scalar. Short 即 GraphQLShort- 基于 java.lang.Short 的 scalar. Byte 即 GraphQLByte- 基于 java.lang.Byte 的 scalar. BigDecimal 即 GraphQLBigDicimal 基于 java.math.BigDecimal 的 scalar. BigInteger 即 GrapQLBigInteger 基于 java.math.BigInteger 的 scalar. graphql.Scalars类包含了提供 scalar 类型的单例实例. 自定义 scalars你可以实现自定义 scalar.在运行时你需要完成类型强制转换,后面会解释.假设我们需要一个 email 的 scalar 类型.它把 email 地址作为输入输出.我们将创建一个如下的 graphql.schema.GraphQLScalarType 单例实例. 12345678910111213141516public static final GraphQLScalarType EMAIL = new GraphQLScalarType("email","A cusom scalar that handles emails",new Coercing() &#123; @Override public Object serialize(Object dataFetcehrResult) &#123; return serilizeEmail(dataFetcherResult); &#125; @Override public Object parseValue(Object input) &#123; return parseEmailFromVariable(input); &#125; @Override public Object parseLiteral(Object input) &#123; return parseEmailFromAstLiteral(input); &#125;&#125;); 强制类型转换自定义 scalar 实现的真正作用点在 graphql.schema.Coercing实现.有 3 个函数需要实现 parseValue- 接收一个输入变量,转换为 java 运行时实现. parseLiteral-接收一个 AST 字符 graphql.language.Value 作为输入,转换为 java 运行时实现. serialize-接收一个 Java 对象,最终转为 scalar 输出类型.所以你自定义的 scalar 实现需要处理 2 中类型的输入(parseValue/parseLiteral)和 1 中输出(serialize).如下查询,使用了变量,AST 字符然后输出我们需要的 scalar 类型 email. 123456789mutation Contact($mainContact: Email!) &#123; makeContact( mainContactEmail: $mainContact backupContactEmial: &quot;backup@company.com&quot; ) &#123; id mainContactEmail &#125;&#125; 我们的自定义 email scalar 类型将 调用 parseValue 将 $mainContact变量转为运行时对象. 调用 parseLiteral 将 AST graphql.language.StringValue “backup@company.com“ 转换为运行时对象. 调用 serialize 将 mainContactEmial 运行时实现转为输出对象形式. 输入输出校验例如我们的 email scalar 将会校验输入输出是否是真是的 email 地址.graphql.schema.Coercing 协议如下: serialize 只允许抛出 graphql.schema.CoercingSerializeException.这表明值无法被序列化为合适的形式.决不允许指定其他运行时异常以取得普通的 graphql 校验行为.必须返回一个非 null 值. parseValue 只允许抛出 graphql.schema.CoercingParseValueException.这表明值无法被作为输入解析为合适的形式..决不允许指定其他运行时异常以取得普通的 graphql 校验行为.必须返回一个非 null 值. parseLiteral 只允许抛出 graphql.schema.CoercingParseLiterialException.这表明 AST 值无法被作为输入解析为合适的形式..决不允许指定其他运行时异常以取得普通的 graphql 校验行为.有的人尝试依赖运行时异常校验以期获取普通的 graphql 错误.这是行不通的.必须遵照 Coercing 方法协议使 graphql-java 引擎按照 grapqhl 的 scalar 类型规范运行. 示例实现下面是一个简单的 email scalar 类型实现,展示了如何通过继承 Coercing 实现一个 scalar. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static class EmailScalar &#123; public static final GraphQLScalarType EMAIL = new GraphQLScalarType("email","A custom scalar that handles emails",new Coercing() &#123; @Override public Object serialize(Object dataFetcherResult) &#123; return serializeEmail(dataFetcherResult); &#125; @Override public Object parseValue(Object input) &#123; return parseEmailFromVariable(input); &#125; @Override public Object parseLiterial(Object input) &#123; return parseEmialFromAstLiterial(input); &#125; &#125;); private static boolean looksLikeAnEmailAddress(String possibleEmailValue) &#123; return Pattern.matches("[A-Za-z0-9]@[.*]",possibleEmailValue); &#125; private static Object serialzeEmail(Object dataFetcherResult) &#123; String possibleEmailValue = String.valueOf(dataFetcherResult); if (looksLikeAnEmailAddress(possibleEmailValue)) &#123; return possibleEmailValue; &#125; else &#123; throw new CoercingSerializeException("Unable to serialize" + possibleEmailValue + " as an email address"); &#125; &#125; private static Object parseEmailFromVariable(Object input) &#123; if (input instanceof String) &#123; String possibleEmailValue = input.toString(); if (looksLikeAnEmailAddress(possibleEmailValue)) &#123; return possibleEmailValue; &#125; &#125; throw new CoercingParseValueException("Unable to parse variable value " + input + " as an email address"); &#125; private static Object parseEmailFromAstLiterial(Object input) &#123; if (input instanceof StringValue) &#123; String possibleEmailValue = ((StringValue)input).getValue(); if (looksLikeAnEmailAddress(possibleEmailValue)) &#123; return possibleEmailValue; &#125; &#125; throw new CoercingParseLiterialException("Unable to parse variable value " + input + " as an email address"); &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-Data mapping]]></title>
    <url>%2F2019%2F05%2F05%2FGraphQL-Data-mapping%2F</url>
    <content type="text"><![CDATA[Mapping datagraphql 是如何把对象数据匹配到类型的graphql 内部全部是关于声明类型 schema,然后在运行匹配到数据.作为类型 schema 的设计者,你应该在处理这些元素. 12345678910type Query &#123; products(match: String): [Product] # a list of products&#125;type Product &#123; id: ID name: String description: String cost: Float tax: Float&#125; 然后可以执行查询 12345678query ProductQuery &#123; products(match: &quot;Paper*&quot;) &#123; id name cost tax &#125;&#125; 对于 Query.products属性有一个绑定的 DataFetcher负责查找匹配输入参数的 product s 列表.假设我们有 3 个下游服务.一个获取产品信息,一个获取产品价格信息,一个计算查新税收信息.graphql-java 使用这些对象运行 data fetcher,获取信息然后将其匹配到 schema 指定的类型中.我们的目标是获取到这 3 个源的信息,然后把它们作为一个 unified 类型展示.我们可以对 cost 和 tax 需要计算的属性指定 data fetcher,但这需要更多的维护精力,可能导致 N+1 性能问题.我们最好在 Query.products data fetcher 中获取所有的信息,同时创建一个 unified 数据视图. 12345678910DataFetcher produtctsDataFetcher = new DataFetcher() &#123; @Override public Object get(DataFetchingEnvironment env) &#123; String matchArg = env.getArgument("match"); List&lt;ProductInfo&gt; productInfos = getMatchingProducts(matchArg); List&lt;ProductCostInfo&gt; productConstInfo = getProdutConsts(productInfo); List&lt;ProductTaxInfo&gt; productTaxInfo = getProductTax(productInfo); return mapDataTogether(productInfo,productCostInfo,productTaxInfo); &#125;&#125; 上面有 3 个类型的信息需要被整合为一个以便 graphql 查询可以访问 id,name,cost,tax 属性.有 2 中方法可以创建这个映射.一个是使用类型不安全的 List&lt;Map&gt; 结构,另一个是使用类型安全的 List&lt;ProductDTO&gt;封装这些数据. 123456789101112131415161718private List&lt;Map&gt; mapDataTogetherViaMap(List&lt;ProductInfo&gt; productInfo,List&lt;ProductCostInfo&gt; productCostInfo,List&lt;ProductTaxInfo&gt; productTaxInfo) &#123; List&lt;Map&gt; unifiedView = new ArrayList&lt;&gt;(); for (int i = 0;i &lt; productInfo.size();i++) &#123; ProductInfo info = productInfo.get(i); ProductCostInfo cost = productCostInfo.get(i); ProductTaxInfo tax = productTaxInfo.get(i); Map&lt;String,Object&gt; objectMap = new HashMap&lt;&gt;(); objectMap.put("id",info.getId()); objectMap.put("name",info.getName()); objectMap.put("descriptioin",info.getDescription()); objectMap.put("cost",cost.getCost()); objectMap.put("tax",tax.getTax()); unifiedView.add(objectMap); &#125; return unifiedView;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class ProductDTO &#123; private final String id; private final String name; private final String description; private final Float cost; private final Float tax; public ProductDTO(String id, String name, String description, Float cost, Float tax) &#123; this.id = id; this.name = name; this.description = description; this.cost = cost; this.tax = tax; &#125; public String getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public Float getCost() &#123; return cost; &#125; public Float getTax() &#123; return tax; &#125;&#125;private List&lt;ProductDTO&gt; mapDataTogetherViaDTO(List&lt;ProductInfo&gt; productInfo, List&lt;ProductCostInfo&gt; productCostInfo, List&lt;ProductTaxInfo&gt; productTaxInfo) &#123; List&lt;ProductDTO&gt; unifiedView = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; productInfo.size(); i++) &#123; ProductInfo info = productInfo.get(i); ProductCostInfo cost = productCostInfo.get(i); ProductTaxInfo tax = productTaxInfo.get(i); ProductDTO productDTO = new ProductDTO( info.getId(), info.getName(), info.getDescription(), cost.getCost(), tax.getTax() ); unifiedView.add(productDTO); &#125; return unifiedView;&#125; graphql 引擎现在可以使用 object 列表然后运行查询获取 id,name,cost,tax 属性.graphql-java 默认的 data fetcher graphql.schema.PropertyDataFetcher 同时支持 map 和 POJO.对于列表的每一个对象都会通过 id 属性,或使用 name 在 map 里查找,或通过 getId() 方法获取,然后返回给 graphql response.对于查询中的每个类型都会执行这样的操作.通过在高级 data fetcher 中创建一个 unified view,你就可以在运行时数据和 graphql schema 之间建立一个映射.]]></content>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-Execution]]></title>
    <url>%2F2019%2F05%2F04%2FGraphQL-Execution%2F</url>
    <content type="text"><![CDATA[ExecutionQueries对 schema 执行 query,使用合适的参数构建一个新的 GraphQL 对象,然后调用execute().query 的结果是包含查询数据或者（并且）一系列错误的ExecutionResult 对象. 123456GraphQLSchema schema = GraphQLSchema.newSchema().query(queryType).build();GraphQL graphQl = GraphQL.newGraphQL(schema).build();ExecutionInput executionInput = ExecutionInput.newExecutionInput().query("query &#123; hero &#123; name &#125;&#125;");ExectionResult executionResult = graphQl.execute(executionInput);Object data = executionResult.getData();List&lt;GraphQLError&gt; errors = executionResult.getErrors(); 更多复杂的查询示例请参考StarWars query tests; Data Fetchers每个 graphql 属性类型都有一个 graphql.schema.DataFetcher 与之关联.其他 graphql 实现通常把这个类型成为 resolvers.通常可以使用graphql.schema.PropertyDataFetcher来检查 提供属性值的 Java POJO 对象.如果某个属性未指定 data fetcher,默认会使用这个.然而你可能需要使用自定义的 data fetcehr 获取你的顶级域对象.可能涉及到数据库调用或通过 HTTP 请求其他系统.graphql-java不关心你是如何获取你的域对象,这是你需要关心的地方.同时也不关心用户访问数据授权.这些都应该放到你自己的逻辑处理层.data fetcher 示例如下: 123456DataFetcher userDataFetcher = new DataFetcher() &#123; @Override public Object get(DataFetchingEnvironment environment) &#123; return fetchUserFromDatabase(environment.getArgument("userId")); &#125;&#125;; 每个 DataFetcher都会传递一个 graphql.schema.DataFetchingEnvironment 对象(包含了将要获取的属性,获取该属性所需提供的参数和其他信息如属性的父对象,query 根对象或 query 上下文对象).上例中,execution将会在 data fetcher 返回结果后才继续执行.可以通过返回CompletionStage 对象使 DataFetcher 异步执行,详情请继续阅读. 当获取数据时发生异常如果在 data fetcher 调用中发生异常,那么默认执行策略将生成graphql.ExceptionWhileDataFetching 错误,然后添加到结果中的错误集中.切记 graphql 允许带错误的部分结果.下面是标准的行为. 1234567891011121314public class SimpleDataFetcherExceptionHandler implements DataFetcherExceptionhandler &#123; private static final Logger log = LoggerFactory.getLogger(SimpleDataFetcherExceptionHandler.class); @Override public void accept(DataFetcherExceptionHandlerParameters handlerParameters) &#123; Throwable exception = handlerParameters.getException(); SourceLocation sourceLocation = handlerParameters.getField().getSourceLocation(); ExecutionPath path = handlerParameters.getPath(); ExceptionWhileDataFetching error = new ExceptionWhileDataFetching(path,exception,sourceLocation); handlerParameters.getExecutionContext().addError(error); log.warn(error.getMessage(),exception); &#125;&#125; 如果你抛出的是GraphqlError,那么它会从 exception 中转换 message 和自定义扩展属性到 ExceptionWhileDataFetching对象.此处允许你向调用者返回自定义的属性到 graphql error.例如想象你的 data fetcher 将抛出这个异常.foo 和 fizz 属性将被添加到返回的 graphql error 中. 12345678910111213141516171819class CustomRuntimeException extends RuntimeException implements GrapQLError &#123; @Override public Map&lt;String,Object&gt; getExtension() &#123; Map&lt;String,Object&gt; customAttributes = new LinkedHashMap&lt;&gt;(); customAttributes.put("foo","bar"); cutomAttributes.put("fizz","whizz"); return customAttributes; &#125; @Override public List&lt;SourceLocation&gt; getLocation() &#123; return null; &#125; @Override public ErrorType getErrorType() &#123; return ErrorType.DataFetchingException; &#125;&#125; 你可以通过创建自己的 graphql.execution.DataFetcherExceptionHandler异常处理代码改变此默认行为,给出你自己的执行策略.例如上面的代码记录了基础异常和堆栈跟踪.有的人可能不喜欢在输出错误列表中看到这些.所以你可以使用这个机制改变这个行为. 1234567DataFetcherExceptionHandler handler = new DataFetcherExceptionHandler() &#123; @Override public void accept(DataFetcherExceptionHandlerParameters handlerParameters) &#123; &#125;&#125;;ExecutionStrategy executionStrategy = new AsyncExecutionStrategy(handler); 返回值和错误在DataFetcher实现中通过直接或者使用 CompletableFuture 实例包装异步执行返回 graphql.execution.DataFetcherResult 来实现同时返回数据和多个错误.当你的DataFetcher 需要从多个数据源或其他 GraphQL 资源获取数据时特别有用.在这个 🌰 中,DataFetcher 从另一个 GraphQL 资源中获取 user 同时返回数据和错误. 1234567891011DataFetcher userDataFetcher = new DataFetcher() &#123; @Override public Object get(DataFetchingEnvironment environment) &#123; Map response = fetchUserFromRemoteGraphQLResource(environment.getArgument("userID")); List&lt;GralhQLError&gt; errors = response.get("errors) .stream() .map(MyMapGraphQLError::new) .collect(Collections.toList()); return new DataFetcherResult(response.get("data"),errors); &#125;&#125; 将结果序列化为 JSON调用 graphql 最常见的方法是通过 HTTP,返回 JSON 响应.所以你需要将 graphql.ExecutionResult 转为 JSON.最常用的实现是使用 Jackson 或 GSON 这样的 JSON 序列化库.然而它们解析数据的方式有它们自己的一套方式.例如 nulls对 graphql 结果是很重要的,所以你必须在设置 json mapper 时包含它.为了保证你获取的 JSON 结果 100% 符合 graphql 的需求,你应该对结果调用toSpecification,然后将其作为 JSON 返回.这将会确保返回的结果符合规范. 123ExecutionResult executionResult = graphQL.execute(executinInput);Map&lt;String,Object&gt; toSpecificationResult = executionResult.toSpecification();sendAsJson(toSpecificationResult); Mutations在这儿学习 mutations.本质上你需要定义一个接收参数作为输入的 GraphQLObjectType .这些参数你可以通过 data fetcher 调用修改你的数据存储. 123456mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125; 在执行 mutation 操作中需要传递参数,本例中是 $ep 和 $review 参数.你可以像这样创建类型处理 mutation 操作. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455GraphQLInputObjectType episodeType = newInputObject() .name("Episode") .field(newInputObjectField() .name("episodeNumber") .type(Scalars.GraphQLInt)) .build();GraphQLInputObjectType reviewInputType = newInputObject() .name("ReviewInput") .field(newInputObjectField() .name("stars") .type(Scalars.GraphQLString) .name("commentary") .type(Scalars.GraphQLString)) .build();GraphQLObjectType reviewType = newObject() .name("Review") .field(newFieldDefinition() .name("stars") .type(GraphQLString)) .field(newFieldDefinition() .name("commentary") .type(GraphQLString)) .build();GraphQLObjectType createReviewForEpisodeMutation = newObject() .name("CreateReviewForEpisodeMutation") .field(newFieldDefinition() .name("createReview") .type(reviewType) .argument(newArgument() .name("episode") .type(episodeType) ) .argument(newArgument() .name("review") .type(reviewInputType) ) ) .build();GraphQLCodeRegistry codeRegistry = newCodeRegistry() .dataFetcher( coordinates("CreateReviewForEpisodeMutation", "createReview"), mutationDataFetcher() ) .build();GraphQLSchema schema = GraphQLSchema.newSchema() .query(queryType) .mutation(createReviewForEpisodeMutation) .codeRegistry(codeRegistry) .build(); 请注意输入参数类型是 GraphQLInputObjectType.这是很重要的.输入类型只能是这种类型,绝不能使用输出类型如 GraphQLObjectType.标量类型既可以是输入类型也可以是输出类型.这个 data fetcher 执行 mutation,返回一些有意义的输出值. 1234567891011121314private DataFetcher mutationDataFetcher() &#123; return new DataFetcher() &#123; @Override public Review get(DataFetchingEnvironment environment) &#123; Map&lt;String,Object&gt; episodeInputMap = environemnt.getArugment("episode"); Map&lt;String,Object&gt; reviewInputMap = environment.getArugment("review"); EpisodeInput episodeInput = EpisodeInput.fromMap(episodeInputMap); ReviewInput reviewInput = ReviewInput.fromMap(reviewInputMap); Review updatedReview = reviewStore().update(episodeInput, reviewInput); return updatedReview; &#125; &#125;&#125; 异步执行graphql-java 执行查询时可以完全支持异步执行.你可以通过调用 executeAsync() 获取 CompletableFuture的结果. 1234567GraphQL graphql = buildSchema();ExecutionInput executionInput = ExecutionInput.newExecutionInput().query("query &#123; hero &#123; name &#125;&#125;").build();CompletableFuture&lt;ExecutionResult&gt; promise = graphql.executeAsync(executionInput);promise.thenAccept(executinoResult -&gt; &#123; encodeResultToJsonAndSendResponse(executionResult);&#125;);promise.join(); 使用 CompletableFuture 可以在执行完成时组合 action 和 function.最终调用 join() 等待执行完成.graphql-java 使用异步执行的原理是通过 join 调用通过方法execute().所以下面的代码效果是一样的. 123ExecutionResult executionResult = graphql.execute(executionInput);CompletableFuture&lt;ExecutionResult&gt; promise = graphql.executeAsync(executionInput);ExecutionResult executionResult = promise.join(); 如果 graphql.schema.DataFetcher 返回的是 CompletableFuture&lt;T&gt; 对象,那么这个结果将被组合进整个异步查询执行中.这意味着你可以并行发起多个属性查询请求.你使用的线程池策略取决于你的 data fetcher 代码.下面的代码采用了标准的 java.util.concurrent.ForkJoinPool.commonPool() 线程执行器在另外一个线程提供数据. 123456789DataFetcher userDataFetcher = new DataFetcher() &#123; @Override public Object get(DataFetchingEnvironment environment) &#123; CompletableFuture&lt;User&gt; userPromise = CompletableFuture.supplyAsync(() -&gt; &#123; return fetchUserViaHttp(environment.getArgument("userId")); &#125;); return userPromise; &#125;&#125; 上面的代码用 Java8 Lambdas 可以简略为: 1DataFetcher userDataFetcher = environment -&gt; CompletableFuture.supplyAsync(() -&gt; fetchUserViaHttp(environment.getArgument("userId")); graphql-java 引擎确保所有的 CompletableFuture 对象遵照 graphql 规范组合在一起提供执行结果.这是 graphql-java 创建异步 data fetcher 的快捷方式.使用 graphql.schema.AsyncDataFetcher.async(DataFetcher&lt;T&gt;) 包装一个 DataFetcher.可以使用静态导入创建更易读的代码. 1DataFetcher userDataFetcher = async(environment -&gt; fetchUserViaHttp(environment.getArgument("userId"))); 执行策略继承 graphql.execution.ExecutionStrategy 的类可以用于运行一个查询或修改. graphql-java 提供了大量不同的策略,如果你非常迫切,也可以使用自定义的.当你创建 Graphql 对象时可以确定执行策略. 1234GraphQL.newGraphQL(schema) .queryExecutionStrategy(new AsyncExecutionStrategy()) .mutationExecutionStrategy(new AsyncSerialExecutionStrategy()) .build(); 实际上上面的代码和默认设置一致,大多数情况下是一个明智的策略选择. 异步执行策略默认的查询执行策略是 graphql.execution.AsyncExecutionStrategy,会把每一个属性作为 CompletableFuture 对象分发,并且不关心哪个最先完成.此策略是性能最佳的执行策略.data fetchers 本身会返回 CompletionStage 值,这将导致完全异步的行为. 12345678910query &#123; hero &#123; enemies &#123; name &#125; friends &#123; name &#125; &#125;&#125; AsyncExecutionStrategy 自由分发 enemies 属性和 friends属性.enemies 属性不必等待 friends属性返回.这是非常低效的.无论如何,最终会将结果按顺序排列.查询结果将遵照 graphql 规范,返回结果对应 query 属性顺序.只有 data fetcher 的执行是随机顺序. 异步序列化执行策graphql 规范要求 mutation 必须按照 query 属性的顺序序列化执行.所以 mutation 默认使用 graphql.execution.AsyncSerialExecutionStrategy 策略.它会保证在执行下一个和后面前当前的每个属性执行完毕.也可以在 mutation data fetcher 中返回 CompletionStage 对象,并且会按顺序在下一个 mutation 属性 data fetcher 被分发之前执行完毕. 订阅执行策略graphql 允许对 graphql data 创建有状态的订阅.可以使用 SubscriptionExecutionStrategy实现,同时支持 reactive-stream API.查看了解更多基于 graphql 服务的订阅支持. 查询缓存在 graphql-java 引擎执行查询之前必须被解析和检验,并且这个处理过程可能有些耗时.为了避免重复解析/校验GraphQL.Builder允许PreparsedDocumentProvider实例复用Document实例.注意 ⚠️,这只缓存解析的 Document,不缓存查询结果 1234Cache&lt;String,PreparsedDocumentEntry&gt; cache = Caffeine.newBuilder().maximumSize(10_000).build();GraphQL graphql = GraphQL.newGraphQL(StarWarsSchema.starWarsSchema) .preparsedDocumentProvider(cache::get) .build(); 这个缓存实例应该是线程安全共享的. PreparsedDocumentProvider 是一个只有一个 get 方法的函数接口,我们可以传递一个方法引用到里面以匹配 builder 的签名. 为了实现高缓存覆盖率,推荐属性参数通过变量传递而不是直接在 query 中定义.下面的查询: 12345query HelloTo &#123; sayHello(to: &quot;ME&quot;) &#123; greeting &#125;&#125; 应该这样写: 12345query HelloTo($to: String!) &#123; sayHello(to: $to) &#123; greeting &#125;&#125; 和变量 123&#123; &quot;to&quot;: &quot;Me&quot;&#125; 现在就可以不管提供的变量是什么而重用查询.]]></content>
  </entry>
  <entry>
    <title><![CDATA[GraphQL-DataFetcher]]></title>
    <url>%2F2019%2F04%2F27%2FGraphQL-DataFetcher%2F</url>
    <content type="text"><![CDATA[获取数据graphql 如何获取数据graphql 中的每个属性都关联了一个 graphql.schema.DataFetcher.一些属性会使用专用的 data fetcher 从数据库获取该属性的相关信息.而大多数简单的使用属性名和 Plain Old Java Object(POJO)模式 从内存中获取数据.在其他 graphql 实现中，Data fetcher 被称为 resolver现在声明一个类型定义: 123456789101112type Query &#123; products(match: String): [Product] # a list of products&#125;type Product &#123; id: ID name: String description: String cost: Float tax: Float launchDate(dateFormat: String = &quot;dd,MM,yyyy&quot;): String&#125;]]></content>
      <tags>
        <tag>DataFetcher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动优先的响应式网页设计]]></title>
    <url>%2F2019%2F04%2F12%2F%E7%A7%BB%E5%8A%A8%E4%BC%98%E5%85%88%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[原文 简介本文将探索如何创建移动优先的网页设计体验。 为什么我们需要创建移动优先，响应式，适应式网页设计体验? 如何针对适应式站点组织 HTML 结构以便优化性能，优先考虑灵活性? 如何书写优先定义共享样式、针对大屏和媒体查询构建、使用相对单位的 CSS? 如何编写不引人注目的 Javascript 来有条件地加载内容片段，利用触摸事件和地理定位 我们可以做些什么来进一步增强我们的适应性体验 适应性的必要性随着网络环境越来越复杂，为越来越多的环境提供可靠的网络体验变得极为重要.幸运的是，响应式 web 设计给 web 开发者提供了一些可以匹配任意大小屏幕的工具来组织布局.]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令记录]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Homebrewgradle-completion1234567891011121314brew install gradle-completionecho $fpath | grep "/usr/local/share/zsh/site-functions"# 执行结果Add the following line to your ~/.bash_profile: [[ -r "/usr/local/etc/profile.d/bash_completion.sh" ]] &amp;&amp; . "/usr/local/etc/profile.d/bash_completion.sh"Bash completion has been installed to: /usr/local/etc/bash_completion.d==&gt; gradle-completionBash completion has been installed to: /usr/local/etc/bash_completion.dzsh completions have been installed to: /usr/local/share/zsh/site-functions]]></content>
  </entry>
  <entry>
    <title><![CDATA[gradle]]></title>
    <url>%2F2019%2F03%2F28%2Fgradle%2F</url>
    <content type="text"><![CDATA[Gradle 升级日志5.0 包含了 Kotlin DSL 生产级支持,依赖版本对齐(类似 Maven BOM),任务超时,Java 11 支持 Kotlin DSL 1.0 依赖版本对齐: 同一逻辑组(platform)下的不同模块在依赖树中可以有相同的版本.也可以导入 Maven BOMs 定义 platform. 123456789dependencies &#123; // 导入 BOM.此文件中版本将覆盖依赖树中的其他版本 implementation(enforcedPlatform("org.springframework.boot:spring-boot-dependencies:1.5.8.RELEASE")) // 使用上面定义的版本 implementation("com.google.code.gson:gson") implementation("dom4j:dom4j") // 覆盖上面的版本 implementation("org.codehaus.groovy:groovy:1.8.6")&#125; Gradle build 初始化特性 可搜索文档 任务超时 解析依赖时 HTTP 重试 性能特性 Gradle 可以作为一个低优先级的进程启动: –priority low 或者 org.gradle.priority=low.可以保证 IDE/Browser 不卡,即使是一个很消耗资源的 gradle 任务. 多任务输出属性不再禁用缓存.当使用 @OutputFiles 或 OutputDirectories 标记一个Iterable类型,Gradle 通常会对该任务禁用缓存且输出如下信息: 1Declares multiple output files for the single output property 'outputFiles' via @OutputFiles,@OutputDirectories or TaskOutputs.files() 现在不会再阻止缓存了.对该任务禁用缓存的唯一理由可能是如果输出包含文件树. Java 11 运行时支持 插件授权特性 Provider 追踪产品任务：Provider API 实例提供了追踪某值和任务或生成该值的任务。 Gradle Native 特性 推广特性 Gradle 编译语言指南gradle 可以使用不同的语言或 DSL 来执行编译任务基本概念理解以下概念可以帮助书写 gradle 脚本.首先，gradle 脚本是一种可配置脚本.当脚本执行时，会生成一个特定类型的配置对象.例如 build script 执行时，会生成一个类型为 Project 的配置对象.这个对象作为脚本的代理对象被使用.下面显示了 gradle 脚本对应的代理对象. 脚本类型 代理对象 build script Project init script Gradle settings script settings 在脚本内可以使用这些代理对象的属性和方法. build script 结构一段编译脚本由 0 个或多个语句和脚本块组成。语句可以包含方法调用，属性赋值，定义局部变量。一个脚本块是一个接受 closure 作为参数的方法调用.这个 closure 可以看作是一个当其执行时配置了一些代理对象的可配置 closure. 最顶层的脚本块如下 脚本块 描述 allprojects{} 配置此项目及其所有子项目 artifacts{} 配置此项目的发布产物 buildscript{} 配置此项目的 build script classpath configurations{} 配置此项目的依赖配置项 dependencies{} 配置此项目的依赖 repositories{} 配置此项目的仓库 sourceSets{} 配置此项目的 source set subprojects{} 配置此项目的子项目 publishing{} 配置由 publishing plugin 添加的 publishingExtension 一段编译脚本同时也是一个 groovy 脚本,所以可以包含能出现在 groovy 脚本中的元素,如 方法定义，类定义 核心类型以下是在 gradle 脚本中常用的核心类型 类型 描述 Project 此接口是你在你的编译脚本中最常使用的 API。通过 Project,你可以使用 gradle 的所有特性 Task 一个 task 代表一个编译过程中的一个单一原子任务，如编译 class,生成 javadoc Gradle 表示 gradle 的调用 Settings 声明实例化和配置要参与构建的 Project 实例的层次结构所需的配置 Script 此接口由所有的 gradle 脚本实现并添加一些 gradle 特定的方法。当你编译脚本类时将会实现此接口，你可以在脚本中使用此接口声明的方法和属性 JavaToolChain 一组用于编译 Java 源文件的工具 SourceSet 表示 Java 源文件和资源文件的逻辑组 SourceSetOutput 所有输出目录的集合(编译的类，处理过的资源等),SourceSetOutput 继承自 FileCollection SourceDirectorySet 表示一组由一系列源文件目录组成的源文件。以及相关的 include 和 exclude pattern IncrementalTaskInputs 提供通过增量任务访问任意需要被处理文件的途径 Configuration 表示一组产物及其依赖。从 ConfigurationContainer 中可以获取更多关于对 configuration 声明依赖或者管理 configuration 的信息 ResolutingStrategy 定义依赖解析的策略.例如强制固定依赖版本号，替代，冲突解决方案或快照 ArtifactResolutingQuery 发起可以解析特定组件的指定软件产物的查询的生成器 ComponentSelection 表示一个模块的组件选择器和某个组件选中规则中评估的候选版本的元组 ComponentSelectionRules 表示组件选中规则的容器.规则可以作为一个 configuration 的解析规则一部分被使用，而且独立的组件可以明确接受或拒绝该规则。既不接受也不拒绝的组件将被指定到默认的版本匹配规则 ExtensionAware 在运行时可以和其他对象一起被扩展的对象 ExtraPropertiesExtension Gradle 域对象的附加 ad-hoc 属性 PluginDependenciesSpec 在脚本中使用的声明插件的 DSL PluginDependencySpec 插件依赖的可变规范 PluginManagementSpec 配置插件如何被解析 ResourceHandler 提供访问特定资源的工具方法的途径,例如创建各种资源的工厂方法 TextResourceFactory 创建由字符串、文件、存档实体等资源提供的 TextResources type-safe model accessors执行时机：plugins{} 块后，script 脚本之前. 123456789101112131415161718192021222324252627282930313233// build.gradle.ktsplugins &#123; `java-library`&#125;dependencies &#123; api(&quot;junit:junit;4.12&quot;) implementation(&quot;junit:junit:4.12&quot;) testImplementation(&quot;junit:junit:4.12&quot;)&#125;configurations &#123; implementation &#123; resolutinStrategy.failOnVersionConflict() &#125;&#125;sourceSets &#123; main &#123; java.srcDir(&quot;src/core/java&quot;) &#125;&#125;java &#123; sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11&#125;tasks &#123; test &#123; testLogging.showExceptions = true &#125;&#125; 了解 type-safe accessors 不可用时要执行的操作下面的脚本明确使用了 apply() 方法应用插件.编译脚本无法使用 type-safe accessors,因为 apply() 方法是在这个编译脚本内调用的。你可以采用其他技巧，如下 12345678910111213141516171819202122232425262728293031// build.gradle.ktsapply(plugin = &quot;java-library&quot;)dependencies &#123; &quot;api&quot;(&quot;junit:junit:4.12&quot;) &quot;implementation&quot;(&quot;junit:junit:&quot;4.12&quot;) &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)&#125;configurations &#123; &quot;implementation&quot; &#123; resolutinStrategy.failOnVersionConflict() &#125;&#125;configure&lt;SourceSetContainer&gt; &#123; named(&quot;main&quot;) &#123; java.srcDir(&quot;src/core/java&quot;) &#125;&#125;configure&lt;JavaPluginConvention&gt; &#123; sourceCompatibility = JavaVersion.VERSION_11 targetCompatibility = JavaVersion.VERSION_11&#125;tasks &#123; named&lt;Test&gt;(&quot;test&quot;) &#123; testLogging.showException = true &#125;&#125; 下列情况下，type-safe accessor 不可用 使用 apply(plugin = id) 应用插件 项目 build script 通过 apply(from = “script-plugin.gradle.kts”) 应用的脚本插件 跨项目配置的插件 产物配置1234567891011121314// build.gradle.jtsapply(plugin = &quot;java-library&quot;)&apos;dependencies &#123; &quot;api&quot;(&quot;junit:junit:4.12&quot;) &quot;implementation&quot;(&quot;junit:junit:4.12&quot;) &quot;testImplementation&quot;(&quot;junit:junit:4.12&quot;)&#125;configurations &#123; &quot;implementation&quot; &#123; resolutinStrategy.failOnVersionConflict() &#125;&#125; 123456789101112131415// settings.gradle.ktspluginManagement &#123; repositories &#123; google() gradlePluginPortal() &#125; resolutionStrategy &#123; eachPlugin &#123; if (requested.id.namespace == &apos;com.android&apos;) &#123; useModule(&apos;com.android.tools.build:gradle:$&#123;requested.version&#125;&apos;) &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223// build.gradle.ktsval check by tasks.existingval myTask1 by tasks.registeringval compileJava by tasks.existing(JavaCompile::class)val myCopy1 by tasks.registering(Copy::class)va; assemble by tasks.existing &#123; dependsOn(myTask1)&#125;val myTask2 by tasks.registering &#123; description = &quot;some meaningful words&quot;&#125;val test by tasks.existing(Test::class) &#123; testLogging.showStackTrace = true&#125;val myCopy2 by tasks.registering(Copy::class) &#123; from(&quot;source&quot;) into(&quot;destination&quot;)&#125; 升级 Gradle Wrapper如果已经有基于gradlew wrapper的项目,可以通过运行wrapper任务来指定需要的gradle版本. 1./gradlew wrapper --gradle-version=5.3 --distribution-type=bin 当然没必要使用gradle wrapper来安装gradle.调用gradlew或gradlew.bat将会下载并缓存指定版本的 Gradle. 1./gradlew taska CLI 自动补全12brew install gradle-completionecho $fpath | grep "/usr/local/share/zsh/site-functions" 设计 gradle 插件对 gradle 新手来说，实现 gradle 插件可能是一个坑:组织管理插件逻辑，测试、调试插件代码等.可以在此获取到更多的信息. ### 通过指定 subproject 的路径，可以将本地任何路径下的代码导入工程中，供本地开发调试。 12include ':lib'project(':lib').projectDir = new File('xxx/xxx/lib') com.android.application 插件 applicationVariants 12345678910111213141516// AppExtension 继承自 BaseExtension 唯一扩展的成员变量，它的参数类型是 DefaultDomainObjectSet,这是不同 buildType 及 Flavor 的集合,applicationVariants 最长的是它的 all 方法，如修改 apk 名字def buildTime() &#123; return new Date().format("yyyy-MM-dd",TimeZone.getTimeZone("UTC"))&#125;android &#123; applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; def fileName = "$&#123;variant.buildType.name&#125;-$&#123;variant.versionName&#125;-$&#123;buildTime()&#125;.apk" output.outputFile = new File(output.outputFile.parent,fileName) &#125; &#125; &#125;&#125; defaultConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758defaultConfig &#123; applicationId '**.**.**' applicationIdSuffix '.two' //applicationId的后缀，可以用在想同时安装运行两个Flavor包的时候，比如同时安装debug包和Release包做一些对比。 minSdkVersion 14 minSdkVersion 14 targetSdkVersion 28 versionCode 1 versionName '1.0' versionNameSuffix '.0' // versionName后缀 consumerProguardFiles 'proguard-rules.pro' //用于Library中，可以将混淆文件输出到aar中，供Application混淆时使用。 dimension 'api' //给渠道一个分组加维度的概念，比如你现在有三个渠道包，分成免费和收费两种类型， //可以添加一个dimension, 打渠道包的时候会自动打出6个包，而不需要添加6个渠道， // 详细的说明可见 https://developer.android.com/studio/build/build-variants.html#flavor-dimensions。 externalNativeBuild &#123; //ndk的配置，AS2.2之后推荐切换到cmake的方式进行编译。 cnamke &#123; cppFlags '-frtti --fexceptions' arguments '-DANDROID_ARM_NEON=TRUE' buildStagingDirectory './outputs/cmake' path 'CMakeLists.txt' version '3.7.1' &#125; ndkBuild &#123; path 'Android.mk' buildStagingDirectory './outputs/ndk-build' &#125; &#125; javaCompileOptions &#123; annotationProcessorOptions &#123; // 注解的配置 includeCompileClasspath true // 使用注解功能 arguments = [ eventBusIndex : 'org.greenrobot.eventbusperf.MyEventBusIndex' ] // AbstractProcessor 中可以读取到该参数 classNames &#125; &#125; manifestPlaceholders = [key: 'value'] // manifest 占位符，定义参数给 manifest 调用，如不同的渠道id multiDexEnabled true // 启用 multiDex multiDexKeepFile file('multiDexKeep.txt') // 手动拆包，将具体的类放在主 dex mutliDexKeepProguard file('multiDexKeep.pro') // 支持 proguard 语法，进行一些模糊匹配. ndk &#123; abiFilterss 'x86','x86_64','armeabi' // 只保留特定的 abi 输出到 apk &#125; proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' // 混淆文件的列表，如默认的 android 混淆文件及本地的 proguard 文件，切记不要遗漏 android 混淆文件，否则导致一些默认安卓组件无法找到 signingConfig &#123; storeFile file('debug.keystore') // 签名文件路径 storePassword 'android' // 签名文件密码 keyAlias 'androiddebugkey' // 别名 keyPassword 'android' &#125; buildConfigField('boolean','IS_RELEASE','false') // 在代码中可以通过 BuildConfig.IS_RELEASE 调用。默认 false resValue('string','appname','demo') // 在 res/value 中添加 &lt;string name="appname" translatable="false"&gt;demo&lt;/string&gt; resConfigs 'cn','hdpi' // 指定特定资源，可以结合 productFlavors 实现不同渠道的最小的 apk 包.&#125; productFlavors: 渠道包的列表，可覆盖 defaultConfig 的参数配置,形成自己的风味 flavorDimensionList: 添加纬度的定义 resourcePrefix: 在模块化开发中给每个模块指定一个特定的资源前缀，避免多模块使用相同的文件名后合并冲突，在 build.gradle 指定此配置后，AS 会检查不合法的资源命名并报错 buildTypes: 默认有 debug 和 release。 123456789101112debug &#123; applicationIdSuffix '.debug' versionNameSuffix '.1' debugable true // 生成的 apk 是否可调试，debug -&gt; true,release -&gt; false jniDebuggable true // 是否可以调试 NDK 代码，使用 lldb 进行 c/c++ 代码调试 crunchPngs true // 是否开启 png 优化，会对 png 图片做一次最优压缩，影响编译速度, debug -&gt; false,release -&gt; true embedMicroApp true // Android Wear 支持 minifyEnabled true // 是否开启混淆 renderscriptDebuggable false // 是否开启渲染脚本 renderscriptOptimLevel 5 // 渲染脚本等级 默认 5 zipAlignEnabled true // 是否 zip 对齐优化，默认 true&#125; ndkDirectory: 也可在 local.properties 中配置 ndk.dir=/Users/shuttle/Library/Android/sdk sdkDirectory: .. aaptOptions: 资源打包工具 123456aaptOptions &#123; additionalParameters '--rename-manifest-package','cct.cn.gradle.lsn13','-S','src/main/res2','--auto-add-overlay' // appt 执行时的额外参数 cruncherEnabled true // 对 png 进行优化检查 ignoreAssets '*.jpg' // 对 res 目录下的资源文件进行排除，把 res 文件下的所有 .jpg 文件打包到 apk 中 noCompress '.jpg' // 对所有 jpg 文件不压缩&#125; adbExecutable: adb 路径 adbOptions 1234adbOptions &#123; installOptions '-r','-d' // 调用 adb install 命令时默认传递的参数 timeOutInMs 1000 // 执行 adb 命令的超时时间&#125; compileOptions 123456compileOptions &#123; encoding 'UTF-8' // java 源文件的编码格式，默认 utf8 incrmental true // java编译是否使用 gradle 增量编译 sourceCompatibility JavaVersion.VERSION_1_7 // java 源文件编译的 jdk 版本 targetCompatibility JavaVersion.VERSION_1_7 // 编译出的 class 版本&#125; dataBinding 12345dataBinding &#123; enabled = true version = "1.0" addDefaultAdapters = true&#125; defaultPublishConfig: 指定发布的渠道及 BuildType 类型。在 Library 中使用,默认 Release. signingConfigs: 签名配置列表，供不同渠道和 buildType 使用. lintOptions 12345678910111213141516171819202122232425lintOptions &#123; quiet true // true -&gt; 不报告分析的进度 abortOnError false // true -&gt; 发现错误时终止 gradle ignoreWarnings true // true -&gt; 只报告错误 absolutePaths true // true -&gt; 当有错误时显示文件的全路径或绝对路径 checkAllWarnings true // true -&gt; 检查所有问题，包括默认不检查问题 warningsAsErrors true // true -&gt; 将所有警告视为错误 disable 'TypeographyFractions','TypographyQUotes' // 不检查给定问题 id enable 'RtlHardCoded','RtlCompat','RtlEnabled' // 检查给定问题 id check 'NewApi','InlinedApi' // 仅 检查给定问题 id noLines true // 如果为 true,则在错误报告的输出中不包含源代码行 showAll true // true -&gt; 对一个错误的问题显示它所在的所有地方，而不会截短列表等等。 lintConfig file('default-lint.xml') // 重置 lint 配置(使用默认的严重性等设置) textReport true // true -&gt; 生成一个问题的纯文本报告(default -&gt; false) textOuput 'stdout' // 默认写入输出结果的位置，可能是一个文件或 stdout xmlReport false // true -&gt; 生成 xml 报告，jenkins 可以使用 xmlOutput file("lint-report.xml") // 写入报告的文件，默认 line-results.xml htmlReport true // html 报告 htmlOutput file('lint-report.html') // 写入报告的路径，可选(默认为构建目录下的 lint-results.html) checkReleaseBuilds true // true -&gt; 将使所有 release 构建都以 issus 的严重性级别为 fatal (serverity=false)的设置来运行 lint,且如果发现了致命(fatal)的问题,将会中止构建(由上面提到的 abortOnError 控制) fatal 'NewApi','InlineApi' // 设置给定问题的严重级别(serverity)为 fatal（即将会在 release 构建期间检查,即使 lint 要检查的问题没有包含在代码中） error 'Wakelock','TextViewEdits' // 设置给定问题的严重级别为 error warning 'ResourceAsColor' // 设置给定问题的严重级别为 warning ignore 'TypographyQUotes' // 设置给定问题的严重级别(serverity)为 ignore (和不检查该问题一样)&#125; dexOptions: 热修复差分包 123456789dexOptions &#123; additionalParameters '--minimal-main-dex','--set-max-idx-number=10000' // dx 命令附加参数 javaMaxHeapSize '2048m' // 执行 dx 时 Java 虚拟机可用的最大内存大小 jumboMode true // 开启大模式，所有的 class 打到一个 dex 中,可以忽略 65535 方法数的限制, 大于14版本可用 keepRuntimeAnnotatedClasses true // 在 dex 中是否保留 Runtime 注解,默认 true maxProcessCount 4 // dex 中的进程数,默认 4 threadCount 4 // 默认线程数 preDexLibraries true // 对 library 预编译，提高编译效率，但 clean 时较慢，默认 true&#125; packagingOptions 12345packagingOptions &#123; pickFirsts = ['META-INF/LICENSE'] // 当有重复文件时，打包会报错。此配置会使用第一个匹配的文件打包进入 apk merge 'META-INF/LICENSE' // 重复文件会合并打包 exclue 'META-INF/LICENSE' // 打包时排除匹配文件&#125; sourceSets 1234567891011121314151617sourceSets &#123; main &#123; res.srcDirs 'src/main/res' jniLibs.srcDirs = ['libs'] aidl.srcDirs 'src/main/aidl' assets.srcDirs 'src/main/assets' java.srcDirs 'src/main/java' jni.srcDirs 'src/main/jni' renderscript.srcDirs 'src/main/renderscript' resources.srcDirs 'src/main/resources' manifest.srcFile 'src/main/AndroidManifest.xml' &#125; // 除了 main,也可给不同的渠道指定不同的配置 free &#123; &#125;&#125; splits: google play 按 CPU/屏幕像素密度打包 123456789101112131415161718192021splits &#123; abi &#123; enable true // 开启 abi 分包 universalApk true // 是否创建一个包含所有有效动态库的 apk reset() // 清空 defaultConfig 配置 include 'x86','armeabi' // 和 defaultConfig 做和集 eclude 'mips' &#125; density &#123; enable true // 开启 density 分包 reset() // 清空默认 include 'xhdpi','xxhdpi' // 和集 exclude 'mdpi' &#125; language &#123; enable true include 'en','cn' &#125;&#125; variantFilter: 过滤通过 flavor 和 buildType 构建的 apk 123456789variantFilter &#123; variant -&gt; def buildTypeName = variant.buildType.name def flavorName = variant.flavors.name if (flavorName.contains("360") &amp;&amp; buildTypeName.contains("debug")) &#123; // 不生成匹配的 apk setIgnore(true) &#125;&#125; com.android.library 1234android.libraryVariants.all &#123; variant -&gt; def mergedFlavor = variant.getMergedFlavor() mergedFlavor.manifestPlaceholers = [hostName:'www.example.com']&#125;]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>gradle</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 笔记]]></title>
    <url>%2F2019%2F03%2F17%2Fgit-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[config 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192# 修改配置git config --local # 对某个仓库有效git config --global # 对当前用户所有仓库有效git config --system # 对系统所有登录用户有效# 查看配置git config --list --localgit config --list --globalgit config --list --system# 打开编辑器修改configgit config -e # 仅对当前仓库有效# 变更文件名git mv readme readme.md # 避免 mv x y -&gt; git add -&gt; git rmgit log [分支] --oneline # 一行显示 -n4 # 指定最新的几次提交 --all # 所有分支的提交 --graph # 图形化显示# 打开内置帮助网页.git help --web [log]# guigitk --allgit branch -av# 在 ./git/refs/heads/xxx 中查看信息git cat-file -t master # 返回 git object model 类型: blog, tree, commit, tag -p # 显示所有内容# 删除分支git branch -D [fixup]# 变基git rebase -i# 暂存区和最近一次提交的区别git diff --cached# 将暂存区的内容丢弃git reset HEAD -- &lt;file&gt;# 将暂存区的内容恢复到本地git checkout -- &lt;file&gt;# 设置别名git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st statusgit config --global alias.last 'log -1 HEAD'git config --global alias.unstage 'reset HEAD --'; git unstage fileA === git reset HEAD -- fileAgit config --global alias.visual '!gitk'# 查看各个分支所指的对象 --decorategit log --oneline --decorategit log --oneline --decorate --graph --all# 跟踪远程分支git checkout --track origin/serverfixgit checkout -b sf origin/serverfix; sf 分支追踪 origin/serverfix 分支.# 添加修改正在追踪的上游分支; -u / --set-upstream-togit branch -u origin/serverfix# 当设置好跟踪分支后，可通过 @&#123;upstream&#125; 或 @&#123;u&#125; 快捷方式来引用.所有如果 master 跟踪 origin/master。那么 git merge @&#123;u&#125; 可以取代 git merage origin/master.# 查看所有跟踪分支git branch -vv# 删除服务端的分支git push origin --delete serverfix#git init --bare --shared ; # shared 会自动修改该仓库目录的组权限为可写.# 为服务端配置 SSH 访问sudo adduser gitsu gitcdmkdir .ssh &amp;&amp; chmod 700 .sshtouch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keyscat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keyscat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys# 限制 git 用户只能访问项目，无法登录远程主机.cat /etc/shellswhich git-shellsudo vim /etc/shells； # 将 git-shell 添加sudo chsh git /usr/bin/git-shell; # 限制 git 用户只能利用 SSH 连接对 Git 仓库进行推送和拉去操作，而不能登录机器并取得普通 shell.# 以守护进程的方式设置 git 协议,不需要配置 SSH 公钥.git daemon --reuseaddr --base-path=/opt/git/ /opt/git/;# --reuseaddr 允许服务器在无需等待旧连接超时的情况下重启# --base-path 允许用户在未完全指定路径的条件下克隆项目,结尾的路径将告诉 git 守护进程从何处寻找仓库来导出.如果有防火墙运行，请开放 9418 端口.# 空白错误(换行\tab\。。。)git diff --check# 部分暂存git add --patch#git merge --squash featureB# --squash 接受被合并分支上的所有工作，并将其压缩至一个变更及，使仓库成为真正合并发生的状态，而不是生成一个合并提交.# 打包 archivegit archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gzgit archive master --prefix='project/' --format=zip &gt; `git describe master`.zips#git diff --ours # --theirs # --base -b]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JGit]]></title>
    <url>%2F2019%2F03%2F16%2FJGit%2F</url>
    <content type="text"><![CDATA[前言JGit 是一个基于 EDL(BSD 协议的变种)授权的轻量级、实现 Git 版本控制系统功能(常规仓库访问,网络协议,版本控制核心算法)的纯 Java 库. 入门获取在仓库搜索引擎中搜索 jgit 即可获取各种添加依赖的方式.我现在基本使用的是 gradle 依赖 12implementation("org.eclipse.jgit:org.eclipse.jgit:5.3.0.201903130848-r")implementation("org.eclipse.jgit:org.eclipse.jgit.http.server:5.3.0.201903130848-r") JGit 也具有 CLI(功能比 git CLI 少),可以试一下 JGit 的功能. 手动编译 JGit CLI假设已经 clone EGit 仓库. git clone https://git.eclipse.org/r/jgit/jgit.git 具体查看 12345678~/src/jgit$ mvn clean install# 进入 jgit 可执行文件所在文件夹org.eclipse.jgit.pgm/target/jgit# 查看 version 命令prompt$ ./jgit versionjgit version xxxxx# 如果经常使用 jgit 命令,可以添加执行链接(通常在 /usr/local/bin)sudo ln -s /path/to/jgit /usr/local/bin/jgit 在 JGit CLI 运行命令1234567891011121314151617181920prompt$ ./git# 会列出最常用的命令jgit --git-dir GIT_DIR --help (-h) --show-stack-trace command [ARG ...]The most commonly used commands are: branch List, create, or delete branches clone Clone a repository into a new directory commit Record changes to the repository daemon Export repositories over git:// diff Show diffs fetch Update remote refs from another repository init Create an empty git repository log View commit history push Update remote repository from local refs rm Stop tracking a file tag Create a tag version Display the version of jgit # 常用的 debug test 命令 prompt$ ./jgit debug-show-commands 查看仓库在查看最常用的命令之前，你可能想知道该仓库包含了多少分支，当前分支是那个.使用 branch -v 可以获取所有分支的简略信息，版本号，版本号提交信息的第一行. 12345678910111213prompt$ ./jgit branch -v# master 4d4adfb Git Project import: don't hide but gray out existing projects# * traceHistory 6b9fe04 [historyView] Add trace instrumentation# 和 git-log 一样 log 命令显示提交信息jgit log --author Math --grep tycho master# 显示 master 分钟中，作者名包含 Math,提交信息包含 tycho 的搜有提交信息.# commit xxxx# Author: Math xxxx# Date: xxx# Update build to use tycho x.xx.x# ...# 大多数的搜索都会精确过滤提交日志，如提交者姓名等 历史图形化jgit glog 核心概念API仓库Repository 管理所有的项目和引用，管理代码 12345val repository = FileRepositoryBuilder() .setGitDir(File("/my/git/directory")) .readEnvironment() // 扫描 GIT_* 环境变量 .findGitDir() // 扫描文件系统 .build() Git 对象在 Git object model 所有的对象都是由 SHA-1 id 表示.在 JGit 中是由 AnyObjectId 和 ObjectId类表示.在 Git object model 中定义了四种对象类型: blob: 用于存储文件对象 tree: 可以看作一个文件夹，指向其他的 tree 或 blob commit: 指向一个 tree 的提交信息 tag: 突出提交信息,通常用来标记特殊的 release 版本. 为了从一个仓库中识别一个对象，只要传入一个正确的 revision 字符串即可 1val head = repository.resolve("HEAD") Refref 是一个包含单个对象标识符的变量.对象标识符可以是任何 Git 合法对象(blob,tree,commit,tag)例如,获取 head 的引用. 1val HEAD = repository.findRef("refs/heads/master") RevWalkRevWalk 遍历 commit graph，并按顺序生成匹配的 commit 1val revWalk = RevWalk(repository) RevCommitRevCommit 表示 Git object model 中的一个 commit 1val commit = walk.parseCommit(objectIdOfCommit); RevTagRevCommit 表示 Git object model 中的一个 Tag 1val tag = walk.parseCommit(objectIdOfTag); RevTreeRevCommit 表示 Git object model 中的一个 tree 1val tree = walk.parseCommit(objectIdOfTree); 参考虽然 JGit 包含了许多和 Git 仓库交互的低级代码，同时还有一些参考org.eclipse.jgit.apit包中 Git porcelain 命令的高级 API. 添加命令(git-add)add 命令可以向索引中添加文件，同时可以通过 setter 方法配置 addFilepattern() 1234val git = Git(repository)git.add() .addFilepattern("/dir") .call() 提交命令(git-commit) setAuthor() setCommitter() setAll() 1234git.commit() .setAuthor("author","email") .setMessage("message") .call() tag 命令(git-tag) setName() setMessage() setTagger() setObjectId() setForceUpdate() setSigned(): 暂不支持，会抛异常 123git.tag() .setName("tag") .call() log 命令(git-log) add(AnyObjectId start) addRange(AnyObjectId since,AnyObjectId until) 123git.log() .add(head) .call() merge 命令(git-merge)TODO Ant 任务JGit 在 org.eclipse.jgit.ant 包中提供了 Ant 任务功能.添加依赖 1234567&lt;taskdef resource="org/eclipse/jgti/ant/ant-tasks.properties"&gt; &lt;classpath&gt; &lt;pathelement location="path/to/org.eclipse.jgit.ant-VERSION.jar"/&gt; &lt;pathelement location="path/to/org.eclipse.jgit-VERSION.jar"/&gt; &lt;pathelement location="path/to/jsch-0.1.44-1.jar"/&gt; &lt;/classpath&gt;&lt;/taskdef&gt; 提供了 git-clone、git-init、git-checkout任务. git-clone1&lt;git-clone uri="http://egit.eclipse.org/jgit.git"/&gt; uri(必须) dest(可选): 克隆的目标文件地址.默认使用基于 uri 路径最后一个组件作为可识别的名称的文件夹. bare(可选): true/false/yes/no 表示是否克隆 bare 仓库. 默认 false branch(可选): 默认 HEAD git-init1&lt;git-init/&gt; dest(可选): 默认 \$GIT_DIR 或当前文件夹 bare(可选) git-checkout1&lt;git-checkout src="path/to/repo" branch="origin/experimental"/&gt; src(必须) branch(必须) createbranch(可选): true/false/yes/no 是否会创建新 branch。默认 false. force(可选): true/false/yes/no 如果 true/yes,命名的 branch 已存在，已存在 branch 的起点将会被设置到新的起点。如果 false,存在的 branch 不会被改变.默认 false. git-addTODO 代码片段获取某一提交记录的子记录12345678PlotWalk revWalk = new PlotWalk(repo());ObjectId rootId = (branch == null) ? repo().resolve(HEAD) : branch.getObjectId();RevComment root = revWalk.parseCommit(rootId);revWalk.markStart(root);PlotCommitList&lt;PlotLane&gt; plotCommitList = new PlotCommitList&lt;PlotLane&gt;();plotCOmmitList.source(revWalk);plotCommitList.fillTo(Integer.MAX_VALUE);return revWalk; 高级主题使用 RevWalk 减少内存使用revision walk 接口和 RevWalk，RevCommit 类轻量级设计。然而当面对相当大的仓库时它们可能仍然需要很多内存。接下来提供了一些方法在遍历修订图(walking the revision graph)时减少内存。 限制遍历修订图(Restrict the walked revision graph)仅遍历那些必要的图.即如果查找 refs/heads/master 而不是 refs/remotes/origin/master 的提交记录,确保对 refs/heads/master 调用 markStart(),对 refs/remotes/origin/master 调用 markUninteresting(). RevWalk traversal 讲只解析对你有用的提交记录,而且会避免在历史记录中查询.这讲减少内部 object map 的大小,因此减少整体内存占用. 123456RevWalk walk = new RevWalk(repository);ObjectId from = repository.resolve("refs/heads/master");ObjectId to = repository.resolve("refs/remotes/origin/master");walk.markStart(walk.parseCommit(from));walk.markUnInteresting(walk.parseCommit(to)); 丢弃提交记录内容setRetainBody(false) 可以用来丢弃提交记录内容，如果你不需要作者，提交者，或信息等.不需要该数据的例子如只使用 RevWalk 完成 branch merge 或使用 git rev-list 完成相关功能. 12RevWalk walk = new RevWalk(repository);walk.setRetainBody(false); 如果确实需要这些信息，可以考虑拆分你需要的数据然后对 RevCommit 调用 dispose().如果需要长时间使用这些信息,你会发现 JGit 内部使用的内存比你自己处理占用的内存要少，特别是需要全部的信息时。这是因为 JGit 内部使用 byte 数组保存 UTF-8 编码的信息.如果使用 UTF-16 编码的 Java String 占内存将会变大，假设大部分的消息是 US-ASCII 编码的. 123456RevWalk walk = new RevWalk(repository);Set&lt;String&gt; authorEmails = new HashSet&lt;String&gt;();for (RevCommit commit : walk) &#123; authorEmails.add(commit.getAuthorIdent().getEmailAddress()); commit.dispose();&#125; RevWalk 和 RevCommit 的子类如果需要获取某个提交记录的更多信息，可以考虑使用 RevWalk RevCommit 的子类, RevWalk.createCommit() 构建 RevCommit 子类的实例。然后将更多的信息存入 RevCommit 子类,这样就不需要额外的 HashMap 将 RevCommit 或 ObjectId 转换为 自定义的数据属性. 12345678910111213141516171819202122232425262728293031public class ReviewedRevision extends RevCommit &#123; private final Date reviewDate; private ReviewedRevision(AnyObjectId id,Date reviewDate) &#123; super(id); this.reviewDate = reviewDate; &#125; public List&lt;String&gt; getReviewedBy() &#123; return getFooterLines("Reviewed-by"); &#125; public Date getReviewDate() &#123; return reviewDate; &#125; public static class Walk extends RevWalk &#123; public Walk(Repository repo) &#123; super(repo); &#125; @Override protected RevCommit createCommit(AnyObjectId id) &#123; return new ReviewedRevision(id,getReviewDate(id)); &#125; private Date getReviewDate(AnyObjectId id) &#123; &#125; &#125;&#125; 遍历修订后清理RevWalk 无法缩小内部的 object map.如果刚完成了遍历仓库的所有历史，这将会将所有东西加载到 object map，并且无法被释放.如果再不需要这些数据，好的习惯是丢弃这个 RevWalk，然后为下次遍历重新申请新的 RevWalk。这样 GC 就会回收垃圾。另外，重用一个存在 的 object map 比完全重新创建一个新的更快.所以你需要平衡内存回收和用户渴望更快的操作之间的关系. 123RevWalk walk = new RevWalk(repository);for (RevCommit commit : walk) &#123;&#125;walk.repository(); 功能列表 通用仓库操作 打开存在的 git 仓库 创建新的 git 仓库 git 命令支持 初始化新的仓库 添加新文件到索引中 向存在的仓库提交文件 提交所有更改 列出提交记录,如 Log 列出仓库的所有标签 列出仓库的所有分支 列出仓库的所有提交记录 列出仓库所有未提交的更改 创建/删除分支 创建/删除标签 回退被修改的追踪文件到最近提交记录中的初始状态 返回两个分支的 diff 显示两个 revs 中同一个文件的改变 diff 显示两个提交记录中所有文件的改变 diff 显示两个提交记录中同一个文件的改变 diff,当文件被重命名后 显示状态 把分支中的内容存储到一个压缩文件中 使用自定义的打包格式将分支中的内容写入到一个压缩文件中 Blame,例如查找那个提交记录改变了某个文件的特定行 添加/列出提交记录附带的笔记 列出所有可用的笔记 清理所有未追踪的文件 创建/列出/提交/丢弃 stashes 运行垃圾回收 Blame,如查找谁最后修改了某文件的特定行 合并某一分支的修改 列出两个提交记录修改的所有文件 供远程仓库使用的命令 复制远程仓库到本地的新文件夹中 在一个仓库中迭代远程引用 不克隆列出远程仓库的所有 heads/tags fetch from remote repository fetch from remote repository 且使用 prune 移除过期的远程 branches/tags 使用 SSH 协议/用户名密码验证克隆远程仓库 对一个 upstream 分支执行 Rebase 使用 InMemoryRepository 在内存中克隆一个仓库，并且在内存中完成操作 底层 API 从一个命名 ref (refs/heads/master) 中获取 SHA-1 从一个名称或 SHA-1 获取提交记录对象 获取提交信息 从提交记录对象，名称，SHA-1 获取 tree 对象 读取 file/blob 的内容 从名称，SHA-1 获取 tag 对象 解析复杂的引用(如 HEAD^^)为 SHA-1 迭代一个分支的所有提交记录 迭代某个范围内的提交记录 从特定的提交记录中读取特定文件的内容 列出当前仓库的远程配置 从 Git 中打印出用户的信息 读取文件属性，如可执行状态，是文件还是文件夹，大小等 使用 BranchTrackingStatus 类获取当前分支相对于远程分支超前/落后的提交记录 检查其他分支的某个提交是否被合并到了给出的分支 列出作为某个特定提交记录或标签的文件夹中的所有文件 循环迭代某个提交的文件 非循环迭代某个提交的文件 查找所有可以通过 tags,branches,remotes,HEADs…等可访问的提交记录 缺失的代码片段 迭代仓库的所有提交 单元测试 子模块(http://stackoverflow.com/questions/13426798/jgit-read-gitmodules) diffing 修改之前的提交 从索引中移除一个文件 Amazon S3 上的 git 仓库 cherrypick 更多授权]]></content>
  </entry>
  <entry>
    <title><![CDATA[teamcity自动化更新hexo博客]]></title>
    <url>%2F2019%2F03%2F09%2Fteamcity%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言在知乎找到了一个更好的方法: 原文在这里我整理一下: 创建仓库 xxx.github.io. 创建两个分支: master/hexo.(可在 github 网页或本地创建) git clone git@github.com:xxx/xxx.github.io.git 如果没有在网页创建分支,可以在此处创建.git checkout -b master; git checkout -b hexo 接下来执行 npm install hexo; hexo init; npm i; npm i hexo-deployer-git,此处在 hexo 分支操作 修改 _config.yml 的 deploy 参数,此处在 master 分支操作. 我使用了hexo-next-theme,从 git 上下载后,进入 themes/next 执行 git submodule init,将 next 主题关联,此处在 hexo 分支操作 git add .; git commit -m &quot;blahblahblah&quot;; git push origin hexo; 提交网站相关文件. hexo g -d 生成网站并部署到 github. 将 CNAME,图片等文件放入 source 目录下,可保证推送到 github 不会被删除.⚠️ 👇 胡扯,观看请谨慎!!!TeamCity 是 Jetbrains 公司出品的持续化集成工具，类似Jenkins,界面更加现代化，功能更强大,而且它的 server 和 agent 是分离的，可以指定本机或远程的机器来运行构建策略，其中还有调度队列算法.hexo 是静态博客生成工具.hexo d -g命令可以自动生成 public 文件夹及 HTML，然后将其推送到 github(在_config.yml中已经配置过).一般用户可能对theme自定义(修改theme下的_config.yml),当换机或备份时，希望将博客源文件(*.md)及修改的主题配置文件一并备份.而hexo默认只备份public文件夹,所以本文探索使用 CITeamCity将推送到Github的源文件编译生成public文件,这样每次写完文章,只要将其推送到Github,TeamCity会自动生成博客HTML. 获取到该 Key.而实际上在 build 执行时 key 以 ing 被删除了,不可能获取到.这并不意味着绝对安全，只是增加了 key 被盗的难度. agent 必须安全. teamcity 安装TeamCity提供了 Docker安装方式，因此请提前安装好Docker.文件目录如下(请提前创建),teamcity 支持多种数据存储方式，此处使用 mysql 来存储。 123456789101112# - teamcity - agent - conf - data - server - data - datadir - opt - mysql - backup - data dockery-compose.yml 接下来是docker-compose.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162``yamlversion: "3.3"services: teamcity-server: image: jetbrains/teamcity-server container_name: teamcity-server restart: always ports: - 8111:8111 volumes: - $PWD/server/datadir:/data/teamcity_server/datadir - $PWD/server/opt/logs:/opt/teamcity/logs - $PWD/server/data:/data/teamcity_server/others # 其他的一些资源，可以从本机复制到 server 上 environment: # TEAMCITY_SERVER_MEM_OPTS: -Xmx2g -XX:MaxPermSize=270m -XX:ReservedCodeCacheSize=350m MYSQL_USER: team-user MYSQL_PASSWORD: team-pwd MYSQL_ROOT_PASSWORD: teamcity8080 MYSQL_DATABASE: teamcitydb depends_on: - db links: - db networks: - team db: image: mysql container_name: teamcity-db restart: always volumes: - $PWD/mysql:/etc/mysql/conf.d - $PWD/mysql/backup:/var/lib/mysql # 只有 /var/lib/mysql 对应本地文件为空，才会创建这个数据库,即初次创建时，这个对应的本地文件夹要为空 - $PWD/mysql/data:/others environment: MYSQL_USER: team-user MYSQL_PASSWORD: team-pwd MYSQL_ROOT_PASSWORD: teamcity8080 MYSQL_DATABASE: teamcitydb ports: - 3306:3306 networks: - team # &lt;&gt;&lt;&gt; agent &lt;&gt;&lt;&gt; teamcity-agent: image: jetbrains/teamcity-agent container_name: teamcity-agent restart: always volumes: - $PWD/agent/conf:/data/teamcity_agent/conf - $PWD/agent/data:/data/teamcity_agent/others environment: AGENT_NAME: MacbookPro SERVER_URL: http://xxx.xxx.x.xxx:8111 # 此处对应的是 TeamCityServer 的IP, localhost/127.0.0.1 都不行，请使用正确的 IP,端口对应上面暴露出来的端口 links: - teamcity-server # teamcity_agent 默认的任务环境路径: opt/buildagent/worknetworks: team: driver: bridge 然后执行 docker-compose up -d 即可。 需要先根据本机 OS 安装docker-compose &gt; docker-compose up -d 生成服务docker-compose down 解体服务，删除容器,网络docker-compose start/stop 启动终止服务 打开 http://localhost:8111 或 http://[ip]:8111 即可进入 TeamCity Server web 交互环境.按照提示初始化.登录时默认没有访客创建新用户的权限，所以需要已超级用户权限登录，点击下面的以超级权限登录后提示输入 token,可以进入 TeamCity Server 本地映射文件中查找，或是使用 docker logs teamcity-server 即可看到 token。 创建项目时，TeamCity 默认使用用户名密码连接 Github,当然可以通过上传本地 ssh key 密钥到 TeamCity Server,通过 TeamCity Server 连接. 设置编译步骤,我再次执行了shell 脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#! /bin/bash# 安装 nodejsVERSION=v10.15.2DISTRO=linux-x64function checkNode() &#123; ISNODESUCCEED=$(node -v) if [ ISNODESUCCEED != $VERSION ]; then installNode else echo "NodeJS已安装" fi&#125;function insallNode() &#123; mkdir -p /usr/local/lib/nodejs tar -xJf /data/teamcity_agent/others/node-$VERSION-$DISTRO # -v 会输出解压日志，此处太多，所以关闭 export PATH=/usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin:$PATH source ~/.profile checkNode&#125;checkNode# 安装依赖npm i# 生成public文件./node_modules/hexo/bin/hexo g# 为 github.io 配置 CNAMEif [ ! -f "/CNAME" ]; then echo "blog.dang8080.cn" &gt; CNAMEfi# 配置 gitgit config --global credential.helper store # 保存 github 提交者信息，下次不用再输密码git config --global user.name "Humphrey"git config --global user.email "dang8080@qq.com"git add --allgit commit -m "TeamCity CI 提交部署: $(date)"git push origin master 问题: 所以问题来了,配置完了点击 run 查看 Build log 会发现 push 失败。因为通过 https 向 github 提交代码需要交互式输入用户密码。而此处没有提供，将密码硬编码到此 shell 里提交到 github 也不安全。或者即使是通过修改 VCS root 使用 git@github.com ssh checkout 的代码，也无法推送到 github. 问题定位: TeamCity SSH agent 使用本机(Linux/MacOS)的 OpenSSH 管理 SSH,对于 Windows,需要手动安装 OpenSSH (CygWin,MinGW,Git for Windows).SSH agent 必须添加到 $PATH 中.第一次连接到远程地址时，SSH agent 会询问是否保存远程地址的 fingerprint 到地址数据库 ~/.ssh/known_hosts中.为了避免询问，可以提前配置。如果相信该远程地址，可以禁用远程地址检查 对所有的连接都禁用，~/.ssh/config 123Host \*StrictHostKeyChecking no 特定连接,-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no TeamCity 当前仅支持 PEM 格式的 key.如果使用了其他格式的 key，请将其转换为 PEM.可以在 TeamCity web 界面 Conversions -&gt; Export OpenSSH key 中转换. OpenSSH 最近版本默认不生成 PEM 格式 key.使用下列方式生成 PEM: ssh-keygen -t rsa -m PEM 上传到 TeamCity Server 的 SSH key 默认保存在 &lt;TeamCity Data Directory&gt;/config/projects/&lt;project&gt;/pluginData/ssh_keys，TeamCity 会追踪此文件夹保证 SSH key 更新。SSH key 适用于本项目及子项目. 在 TeamCity agent checkout 执行时，Git 插件会从 TeamCity Server 下载 SSH key 到 agent.该 key 会暂时保存在 TeamCity agent 的文件系统里，在 fetch/clone 结束后就被删除. key 被删除的原因是：通过 build 执行的 test 可能会留下恶意代码，之后会访问 TeamCity agent 文件系统, TeamCity 是不支持 git ssh 推动代码到 github 的.（支持 ssh 传送文件） 方案一:当 run 一次之后，执行 docker exec -it teamcity-agent bash 进入 opt/buildagent/work/xxxxx/ 下,手动 git push origin master。这样后续就不用再配置了 方案二:(硬核)github 需要保存本机的 SSH pub key,才接受 git ssh 推送.那我们就在 TeamCity 生成 ssh key,然后添加到 github. 实践一1234docekr exec -it teamcity-agent bashssh-keygen -t rsassh-add [id_rsa]# 然后复制 id_rsa.pub 的内容到 github 即可 实践二连 TeamCity agent bash 也不想进，使用 shell 构建先安装 expect tcl tk 123456789101112131415161718192021222324apt-get update &amp;&amp; apt-get install tcl tk expect# 下面是 shell#! /usr/bin/expect -fset context $PWD# 删除旧keyspawn rm -f "$context/id_rsa" "$context/id_rsa.pub"expect&#123;&#125;# 生成新keyspawn ssh-keygen -t rsaexpect&#123; "*save the key*" &#123; send "$context/id_rsa\r";exp_continue &#125; "*passphrase*" &#123; send "\r";exp_continue &#125; "*again*" &#123; send "\r" &#125;&#125;spawn ssh-add "$context/id_rsa"sshcheck=$(ssh -vT git@github.com)if [[ $sshcheck =~ "successfully authenticated" ]]; then echo "ssh 配置成功"else echo "ssh 配置失败"fi# 复制 pubpubkey=$(cat "$context/id_rsa)curl -H "Content-Type:application/json" -X POST --data '&#123; "title":"TeamCityAgentAuto","key":"$pubkey"&#125;']]></content>
      <tags>
        <tag>teamcity</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Room & kotlin coroutine]]></title>
    <url>%2F2019%2F03%2F03%2FRoom-kotlin-coroutine%2F</url>
    <content type="text"><![CDATA[OverviewRoom 2.1 开始支持 Kotlin 协程。DAO 方法可以使用 suspend 标记以确保这些方法不会在主线程中被执行。Room 使用 Executor(来自框架组件) 作为 Dispatcher 运行 SQL 语句，当然在编译 RoomDatabase 时，你也可以提供自己的 Executor. 当前协程支持正在开发中，更多特性正在计划中 添加依赖请升级 Room 到 v2.1, 同时 Kotlin v1.3.0+ , Coroutines v1.0.0+ 1implementation "androidx.room:room-coroutines:$&#123;versions.room&#125;" 现在就可以使用啦 123456789101112131415161718@Daointerface UsersDao &#123; @Query("SELECT * FROM users") suspend fun getUsers(): List&lt;User&gt; @Query("UPDATE users SET age = age + 1 WHERE userId = :userId) suspend fun incrementUserAge(userId: String) @Insert suspend fun insertUser(user: User) @Update suspend fun updateUser(user: User) @Delete suspend fun deleteUser(user: User)&#125; 在调用其他 suspending DAO 函数时，@Transaction 也可以被 suspending 123456789101112131415@Daoabstract class UsersDao &#123; @Transaction open suspend fun setLoggedInUser(loggedInUser: user) &#123; deleteUser(loggedInUser) insertUser(loggedInUser) &#125; @Query("DELETE FROM users") abstract fun deleteUser(user: User) @Insert abstract suspend fun insertUser(user: User)&#125; 根据是否在 transaction 内调用，Room 对 suspending 函数处理逻辑不同. 在 Transaction 中 在数据库语句被触发的 CoroutineContext 下，Room 不做任何处理。函数调用者应该确保此方法不会在 UI 线程中执行.因为 suspend 函数只能被其他 suspend 函数 或在 coroutine 内调用，所以你不能把 Dispatchers.Main 赋值给 Dispatcher，应该是 Dispatchers.IO 或自定义 不在 Transaction 中 Room 会确保数据库语句在 Architecutre Components I/O Dispatcher 中触发。该 Dispatcher 在同一个 I/O Executor 的一个后台线程中运行 LiveData 底层12345@Insertfun insertUserSync(user: User)@Insertsuspend fun insertUser(user: User) 对于同步 insert,生成的代码开始启动一个 transaction,然后执行 insert,标记 transaction successfull ，终结。同步方法在被调用处的线程执行. 12345678910@Overridepublic void insertUserSync(final User user) &#123; __db.beginTransaction(); try &#123; __insertionAdapterOfUser.insert(user); __db.setTransactionSuccessful(); &#125; finally &#123; __db.endTransaction(); &#125;&#125; suspending 会确保不会在 UI 线程中执行。生成的代码会传递一个 Continuation.在 Callable#call() 中执行和同步相同的代码 1234567891011121314151617@Overridepublic Object insertUserSuspend(final User user, final Continuation&lt;? super Unit&gt; p1) &#123; return CoroutinesRoom.execute(__db, new Callable&lt;Unit&gt;() &#123; @Override public Unit call() throws Exception &#123; __db.beginTransaction(); try &#123; __insertionAdapterOfUser.insert(user); __db.setTransactionSuccessful(); return kotlin.Unit.INSTANCE; &#125; finally &#123; __db.endTransaction(); &#125; &#125; &#125;, p1);&#125; CoroutinesRoom.execute 会根据数据库是否 open,当前调用是否在 transaction 内来切换处理 context. is open &amp; in transaction 仅调用 insert 逻辑 not in transaction 使用 Architecture Components IO Executor 在后台线程执行 insert 逻辑]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Room</tag>
        <tag>Kotlin</tag>
        <tag>Kotlin 协程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker,docker-compose学习笔记]]></title>
    <url>%2F2019%2F03%2F01%2Fdocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[OverviewCompose 是一个为了定义和运行多容器 Docker 应用的工具。官方动手示例 特性 一个主机多个隔离环境 当容器创建时保留所有的 volume 只有容器被更改时才触发创建 定义变量和在不同环境中使用 使用场景 自动测试环境 单独主机部署 docker-compose 安装1234sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composesudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composesudo docker-compose --version pip 安装 1pip install docker-compose 卸载 12sudo rm /usr/local/bin/docker-composepip uninstall docker-compose docker-compose 命令 -f 指定 一个或多个 compose 文件的名称和路径 1、使用多个 Compose 文件时，Compose 会把这几个文件合并为一个配置。按顺序合并，后边的覆盖前边的配置。2、docker-compose -f docker-compose.yml -f docker-compose.admin.yml run backup_db3、使用 -(dash) 作为 -f 的值，将会从输入中读取配置文件名。使用 stdin 时，配置里涉及到的路径都是相对于当前工作上下文路径。4、如果不是用 -f,Compose 遍历当前上下文路径和它的父路径查询 docker-compose.yml 和 docker-compose.override.yml 文件。请至少提供一个 docker-compose.yml 文件。如果所有的文件都在同一个文件夹下，Compose 将合并它们。5、docker-compose.override.yml 的配置高于 docker-compose.yml,且为后者提供额外的配置属性。 为单独的 Compose 文件指定路径 1、使用 -f, 或从命令行输入，或在 shell / 某个环境配置文件中设置 COMPOSE_FILE 环境变量,指定不在当前文件夹的 Compose 文件路径.2、docker-compose -f ~/sandbox/rails/docker-compose.yml pull db 从 ~/sandbox/rails/docker-compose.yml 文件中获取 db 服务中定义的 postgres db 镜像。 -p 指定项目名 1、如果不指定 -p,Compose 默认使用当前文件夹的名称。 配置环境变量 docker-compose CLI 环境变量默认内置了几个环境变量可以配置 docker-compose.以 DOCKER_ 开头的变量和配置 docker 命令行客户端的变量类似。如果使用 docker-machine的话，eval &quot;$(docker-machine env my-docker-vm)&quot;将为变量设置正确的值。 COMPOSE_PROJECT_NAME 1、设置项目名.该值在启动时会作为容器服务的前缀.比如项目名 myapp,包含两个服务 db 和 web,那么 Compose 启动的容器名为 myapp_db_1 和 myapp_web_1.2、默认时项目文件夹的根目录名。 COMPOSE_FILE 1、指定 Compose 文件路径。如果未指定，Compose 将在当前文件夹查询 docker-compose.yml 文件，如果不存在将继续遍历父目录直到找到。2、支持使用文件路径分隔符(Linux &amp; MacOS [:] Windows [;]).比如 COMPOSE_FILE=docker-compose.yml:docker-compose.prod.yml,路径分隔符可以通过 COMPOSE_PATH_SEPARATOR 自定义 COMPOSE_API_VERSION 1、Docker API 仅支持来自指定版本客户端的请求。使用 docker-compose 时出现 client and server don&#39;t have same version 错误，那么可以通过设置该变量解决。2、设置该变量主要针对临时的运行客户端和服务端版本不一致的情况。 DOCKER_HOST 1、为 docker daemon 设置 URL.和 docker 客户端一样，默认为 unix:///var/run/docker.sock DOCKER_TLS_VERIFY 1、设置空字符以外的任何值时，开启 TLS. DOCKER_CERT_PATH 1、配置 ca.pem,cert.pem,key.pem 的路径。默认 ~/.docker COMPOSE_HTTP_TIMEOUT 1、超时时间(秒).默认 60s COMPOSE_TLS_VERSION 1、TLS 版本.默认 TLSv1. 可供选项 TLSv1, TLSv1_1, TLSv1_2 COMPOSE_CONVERT_WINDOWS_PATH 1、是否开启把 Windos-style 的路径转为 Unix-style 的卷定义。在 Windos 上使用 Docker Machine 和 Docker Toolbox 时总是要设置该变量。默认 0。 true/1 代表开启，false/0 代表关闭. COMPOSE_PATH_SEPARATOR 1、如果设置，COMPOSE_FILE 值将使用此处的定义作为分隔符。 COMPOSE_FORCE_WINDOWS_HOST 1、如果设置，即使 Compose 运行在 Unix-based 系统上，卷定义也将使用简略语法解析为假设运行在 Windows 上的路径。true/a,false/0 COMPOSE_IGNORE_ORPHANS 1、如果设置，Compose 不会试着对项目的单独容器检测。true/1,false/0 COMPOSE_PARALLEL_LIMIT 1、并行执行的限制。默认 64，绝不能低于 2. COMPOSE_INTERACTIVE_NO_CLI 1、如果设置，Compose 不会尝试使用 Docker CLI 和 run exec 操作交互。true/1,false/0 Compose fileversion 3build配置选项在编译期生效。build 可以指定一个路径 1234version: "3"services: webapp: build: ./dir 或者是一个在指定 context 下的路径对象，同时可包含 Dockerfile 和 args 12345678version: "3"services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 如果同时也指定了 image,Compose 使用 webapp 和 image 中指定的可选的 tag 命名最终生成的镜像名 12build: ./dirimage: webapp:tag swarm mode 不支持。docker stack 命令只接受预编译的镜像. CONTEXT可以是包含 Dockerfile 文件的路径，或 git 仓库的 url.如果是相对路径，那么被解析为相对于当前 Compose 文件的路径。此文件夹同时也是发送到 Docker daemon 的编译上下文。 DOCKERFILE可选此处必须指定编译路径 ARGS只有在编译过程中可访问的环境变量。首先，在 Dokcerfile 中指定参数: 12345ARG buildnoARG gitcommithashRUN echo "Build number: $buildno"RUN echo "Bashed on commit: $gitcommithash" 然后在 build 下给该参数复制（可以是键值对列表）： 1234567891011build: context: . args: buildno: 1 gitcommithash: cdc3b19build: context: . args: - buildno=1 - gitcommithash=cdc3b19 你也可以不指定值，它的值就是编译时 Compose 当前运行环境的值. YAML 布尔值(true,false,yes,no,on,off)应该使用引号应用，这样解析器才能把它们解析为 string CACHE_FROM v3.2+ 指定 engine 可以缓存的镜像列表 12345build: context: . cache_from: - alpine:latest - corp/webapp:3.14 LABELS v3.3+ 向生成的镜像添加元数据。可以是数组或目录推荐使用反向 DNS 标记以避免和其他软件冲突 12345678910111213build: context: . labels: com.example.description: "Accounting webapp" com.example.department: "Finance" com.example.label-with-empty-value: ""build: context: . labels: - "com.example.description=Accounting webapp" - "com.example.department=Finance" - "com.example.label-with-empty-value" SHM_SIZE v3.5+ 设置编译生成容器 dev/shm&#39; 分区大小。int 值单位为 byte. string 可以携带单位 1234567build: context: . shm_size: '2gb'build: context: . shm_size: 10000000 TARGET v3.4+ 编译 Dockerfile 中定义的指定版本 123build: context: . target: prod cap_add,cap_drop添加或删除容器的容量。man 7 capabilities 查看可用列表 12345cap_add: - ALLcap_drop: - NET_ADMIN - SYS_ADMIN swarm mode 无效 cgroup_parent为容器指定可选的 cgroup parent 1cgroup_parent: m-executor-abcd swarm mode 无效 command覆盖默认的命令 1command: bundle exec thin -p 3000 也可以是列表 1command: ["bundle", "exec", "thin", "-p", "3000"] configsTips 共享文件夹，卷，绑定挂载 如果你的项目不在 Users目录(cd ~),那么你需要共享驱动器或 Dockerfile 所在位置和当前正在使用的卷。如果出现运行时错误表示文件未找到，那么就是一个挂载卷的请求被拒绝，或服务启动失败，试着共享文件或驱动。挂载卷要求共享项目不在 C:\Users (Windows),或 /Users (Mac) 的驱动，并且如果是运行在 Dokcer Desktop for Windows 的 Linux 容器上的所有应用都需要共享。 如果改变了一个服务的 Dockerfile 或者编译文件夹里的内容，运行 docker-compose build重新编译 官方示例Compose &amp; WordPress 为项目创建空文件夹。该文件夹作为应用的上下文，且只保存构建镜像所需的资源。 创建 docker-compose.yml 1234567891011121314151617181920212223242526272829version: "3.3"services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - "8000:80" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: &#123;&#125;# db_data 卷会保存任何 WordPress 对数据库的改变。# WordPress 通常开放 80 和 443 端口. docker-compose up -d. 如果使用 Docker Machine, 那么运行 docker-machine ip MACHINE_VM 获取运行地址。如果是 destop 版，http://localhost 即可. docker-compose down 移除容器，默认的网络，保留 WordPress 和数据库。docker-compose down --volumes 全部移除。]]></content>
      <tags>
        <tag>docker</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]-LiveData with SnackBar,Navigation and other events(the SingleLiveEvent case)]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AF%91-LiveData-with-SnackBar-Navigation-and-other-events-the-SingleLiveEvent-case%2F</url>
    <content type="text"><![CDATA[原文 view(activity/fragment) 和 ViewModel 交流的比较好的方式是 LiveData observables. view 订阅 LiveData 的改变且随时响应。这适用于连续不断的显示在一个屏幕的数据。但是某些数据却更应该被消费一次，比如 Snackbar 消息，navigation 事件 或 dialog 触发器。与其试着通过扩展 Architecture Components 扩展或库解决这个问题，不如我们可以直面这是个设计缺陷。我们推荐你把你的事件看作是状态的一部分。本文我们将列举一些常见的错误和推荐的解决方案。 ❌ Bad: 1. 对事件使用 LiveData在 LiveData 对象内部直接持有 Snackbar 消息或 navigation 信号。原则上普通的 LiveData 对象可以这样使用，但实际上会暴露一些问题。在 master/detail 架构的 app 中，如下是 maters 的 ViewModel 12345678910// 请不要对事件这样用class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Boolean&gt;() val navigateToDetails : LiveData&lt;Boolean&gt; get() = _navigateToDetails fun userClicksOnButton() &#123; _navigateToDetails.value = true &#125;&#125; 在 View(activity/fragment) 中 123myViewModel.navigateToDetails.observe(this,Observer &#123; if (it) startActivity(DetailsActivity....)&#125;) 此方案的不足在于 _navigateToDetails将会一直为 true,而且不可能回到首屏: 用户点击按钮启动 Details Activity 用户按返回按钮，回到主 Activity 当 activity 进入回退栈时 observers 失活，现在再次激活 从 ViewModel 中调用 navigation 且立即将其设为 false 1234fun userClicksOnButton() &#123; _navigateToDetails.value = true _navigateToDetails.value = false&#125; 但是请注意： LiveData 保存数据但不会保证在接受到事件时发送任何数据。例如，当没有观察者活跃时更新值，那么一个新值将替换原来的值。同时，从不同线程设置属性将会导致竞争状态，此时仅能保证一个观察者被调用。 最主要的问题是，这个方案很难理解而且代码垃圾。所以我们如何保证在 navigation 事件发生时值重置？ ❌Better: 2.使用 LiveData wrapper 事件，在观察者中重置属性.123456listViewModel.navigateToDetails.observe(this,Observer &#123; if (it) &#123; myViewModel.navigateToDetailsHandled() startActivity(DetailsActivity...) &#125;&#125;) 1234567891011121314class ListViewModel: ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Boolean&gt;() val navigateToDetails: LiveData&lt;Boolean&gt; get() = _navigateToDetails fun userClicksOnButton() &#123; _navigateToDetails.value = true &#125; fun navigateToDetailsHandled() &#123; _navigateToDetails.value = false &#125;&#125; 此方案的不足之处在于有些冗余代码 ✅ ok：使用 SingleLiveEventSingleLiveEvent 只适用于部分场景。只发送和更新一次状态的 LiveData 12345678910class ListViewModel: ViewModel &#123; private val _navigateToDetails = SingleLiveEvent&lt;Any&gt;() val navigateToDetails: LiveData&lt;Any&gt; get() = _navigateToDetails fun userClicksOnButton() &#123; _navigateToDetails.call() &#125;&#125; 123myViewModel.navigateToDetails.observe(this, Observer &#123; startActivity(DetailsActivity...)&#125;) 123456789101112131415161718192021222324252627282930313233343536373839// SingleLiveEventpublic class SingleLiveEvent&lt;T&gt; extends MutableLiveData&lt;T&gt; &#123; private static final String TAG = "SingleLiveEvent"; private final AtomicBoolean mPending = new AtomicBoolean(false); @MainThread public void observe(LifecycleOwner owner, final Observer&lt;T&gt; observer) &#123; if (hasActiveObservers()) &#123; Log.w(TAG, "Multiple observers registered but only one will be notified of changes."); &#125; // Observe the internal MutableLiveData super.observe(owner, new Observer&lt;T&gt;() &#123; @Override public void onChanged(@Nullable T t) &#123; if (mPending.compareAndSet(true, false)) &#123; observer.onChanged(t); &#125; &#125; &#125;); &#125; @MainThread public void setValue(@Nullable T t) &#123; mPending.set(true); super.setValue(t); &#125; /** * Used for cases where T is Void, to make calls cleaner. */ @MainThread public void call() &#123; setValue(null); &#125;&#125; 此方案的不足之处在于只有一个订阅者。如果你有多个观察者，那么只有一个被调用且不保证顺序。 ✅ 推荐：使用 Event Wrapper1234567891011121314151617open class Event&lt;out T&gt;(private val content: T) &#123; val hasBeenHandled = false private set // 只读属性 /** * 返回 content, 阻止其再次调用 fun getContentIfNotHandled(): T? &#123; return if (hasBeenHandled) &#123; null &#125; else &#123; hasBeenHandled = true content &#125; &#125; fun peekContent(): T = content&#125; 1234567891011class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;() val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt; get() = _navigateToDetails fun userClicksOnButton(itemId: String) &#123; _navigateToDetails.value = Event(itemId) // Trigger the event by setting a new Event as a new value &#125;&#125; 1234567891011class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;() val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt; get() = _navigateToDetails fun userClicksOnButton(itemId: String) &#123; _navigateToDetails.value = Event(itemId) // Trigger the event by setting a new Event as a new value &#125;&#125; 此方案的优势是用户需要使用 getContentIfNotHandled() 或 peekContent()指定意图。此方法把事件抽象为 state 的一部分：变成仅表示是否被消费的消息。 结论总之，把事件作为状态的一部分。使用这个 EventObserver 在大量事件结束后移除它 1234567class EventObserver&lt;T&gt;(private val onEventUnhandledContent: (T) -&gt; Unit) : Observer&lt;Event&lt;T&gt;&gt; &#123; override fun onChanged(event: Event&lt;T&gt;?) &#123; event?.getContentIfNotHandled()?.let &#123; value -&gt; onEventUnhandledContent(value) &#125; &#125;&#125; 123inline fun &lt;T&gt; LiveData&lt;Event&lt;T&gt;&gt;.observeEvent(owner: LifecycleOwner, crossinline onEventUnhandledContent: (T) -&gt; Unit) &#123; observe(owner, Observer &#123; it?.getContentIfNotHandled()?.let(onEventUnhandledContent) &#125;)&#125;]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>LiveData</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveData]]></title>
    <url>%2F2019%2F02%2F28%2FLiveData%2F</url>
    <content type="text"><![CDATA[LiveData 的优势 确保 UI 和数据状态匹配 LiveData 遵循观察者模式。 无内存泄漏 不会因为 Activity 被终止而崩溃 如果观察者处于 inactive 状态，例如 activity 处于回退栈中，那么它不会接收到任何 LiveData 事件. 不用手动处理生命周期事件 时刻更新数据状态 如果一个观察者的变为 inactive，那么它会在重新 active 时获取最新的数据状态。比如，一个 activiy 如果处于后台，那么它将在重新返回前台时获取到最新的数据。 应对 configuration change 如果一个 activity 或 fragment 由于 configuration change(设备旋转) 导致重新创建，它会立即获取最新可用的数据. 共享资源 可以使用单例模式扩展 LiveData，封装系统服务在 app 内共享。 在 ViewModel 对象中保存可以更新 UI 的 LiveData 对象，而不是在 activity 或 fragment 的原因是： 避免 activty 或 framgent 过度膨胀。UI controller 仅负责展示数据而不是保存数据状态 从特性的 activity 或 fragment 中剥离 LiveData 实例，使得 LiveData 对象可以在 configuration change 中存活。 请在主线程中调用 setValue(T) 更新 LiveData 对象.如果是在工作线程，请调用 postValue(T).]]></content>
      <tags>
        <tag>Architecture Components</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-6-元模型,IDs,UIDs]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-6-%E5%85%83%E6%A8%A1%E5%9E%8B-IDs-UIDs%2F</url>
    <content type="text"><![CDATA[不像 SQLite 这样的数据库，ObjectBox 不需要你创建 database schema.这不意味着 ObjectBox 是无 schema 的。为高效起见，ObjectBox 对存储的数据维护了一个元模型(meta model)。此元模型实际上等价于 ObjectBox 的 schema.它包含了所有属性的类型、indexes 等.不同之处在于 ObjectBox 试图自动管理该元模型.某些情况下，这需要你帮忙. Object 的 IDs 是 @Id 定义的，而 所有 entity 类型的实例都绑定一个 meta model ID. JSON for consistent IDsObjectBox 把一部分元模型保存在 JSON 文件中.此文件应该通过版本控制软件管理,主要原因是：它可以保证 元模型里的 IDs 和 UIDs 跨设备一致.]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-5-更新数据模型]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-5-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[ObjectBox 大多数情况下自动管理数据模型.当添加/删除 entities 或属性时，ObjectBox 自动作出响应。对于其他改变如 保留或改变类型，ObjectBox 需要额外信息。 UIDsObjectBox 通过 unique IDs(UIDs) 来追踪 entities 和属性的变化。所有的 UIDs 都存储在 module-name/objectbox-models/default.json 中,可以使用版本控制软件(git)进行管理。 简单来说: 为了使 UID 相关的改变生效，在这些 entity 或 属性上放置 @Uid 然后编译，在获取进一步提示。 重命名 entities 和 属性需要 UID 注解的原因是: 如果仅仅改变 entities 和属性的名字，ObjectBox 只会意识到 old entity 不见了，而创建了新的 entity.所以告诉 ObjectBox 重命名 entity 和数据，而不是丢弃它们.它们是相同的一个 entity。实际上是在内部给 entity 绑定一个 UID.属性也一样. 实践第一步: 为想要重命名的 entity/属性添加空的 @Uid 注解 123@Entity@Uidpublic class MyName &#123; ... &#125; 第二步: 编译项目，然后会输出错误信息：给出当前 entity/属性的 UID 123error: [ObjectBox] UID operations for entity "MyName": [Rename] apply the current UID using @Uid(6645479796472661392L) - [Change/reset] apply a new UID using @Uid(4385203238808477712L) 第三部: 把上面的 UID 复制到 @Uid() 里 123@Entity@Uid(6645479796472661392L)public class MyName &#123; ... &#125; 第四步: 重命名吧 123@Entity@Uid(6645479796472661392L)public class MyNewName &#123; ... &#125; 或者可以在 default.json 中找到 UID,然后直接使用到 @Uid() 上，重命名即可 修改属性类型想要修改属性类型，那么 ObjectBox 内部得创建一个新类型。因为 ObjectBox 不会迁移数据。 重命名属性类型：这样该属性就会被认为是新属性(如果该属性已经有 @Uid 注解了，则行不通) 1234// old:String year;// new:int yearInt; 告诉 ObjectBox 对新属性使用新 UID. 实践一下第一步：对想修改类型的属性添加 @Uid 注解 12@UidString year; 第二步: 编译获取错误信息 123error: [ObjectBox] UID operations for property "MyEntity.year": [Rename] apply the current UID using @Uid(6707341922395832766L) - [Change/reset] apply a new UID using @Uid(9204131405652381067L) 第三步：为该属性应用新 @Uid,并修改类型. 12@Uid(9204131405652381067L)int year;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-4-entity继承]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-4-entity%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[ObjectBox 允许子类继承 entity 父类持久化的属性。同样也支持继承非 entity 类。1.4+ 也支持多继承.对于父类来说可以使用 @BaseEntity. 无注解: 类本身及其属性不需要持久化 @BaseEntity: 属性在子类中持久化，类本身不持久化 @Entity: 属性在子类中持久化，类本身也持久化 123456789101112131415161718192021222324252627282930// base class:@BaseEntitypublic abstract class Base &#123; @Id long id; String baseString; public Base() &#123; &#125; public Base(long id, String baseString) &#123; this.id = id; this.baseString = baseString; &#125;&#125;// sub class:@Entitypublic class Sub extends Base &#123; String subString; public Sub() &#123; &#125; public Sub(long id, String baseString, String subString) &#123; super(id, baseString); this.subString = subString; &#125;&#125; 1234567891011121314// entities inherit properties from entities@Entitypublic class SubSub extends Sub &#123; String subSubString; public SubSub() &#123; &#125; public SubSub(long id, String baseString, String subString, String subSubString) &#123; super(id, baseString, subString); this.subSubString = subSubString; &#125;&#125; 使用前注意 在继承链中可能存在由 @BaseEntity 注解的类，它们的属性将被忽略，不会成为 entity model 的一部分 不推荐继承一个仅含有 ID 属性的 base entity 类. 某些情况下可以使用 interface 更简单明了 限制 @BaseEntity 注解的父类不能成为 library 的一部分。 没有多态查询(例如查询父类却希望得到子类) 当前无论是 @Entity 还是 @BaseEntity 注解的父类，都不能使用 ToOne ToMany 关联]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-3-自定义类型]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[ObjectBox 支持以下类型（Java）: 1234567891011boolean, Booleanint, Integershort, Shortlong, Longfloat, Floatdouble, Doublebyte, Bytechar, Characterbyte[]StringDate 转换器注解和属性转换使用 @Convert 注解将其他类型属性转为内置属性。此处需要提供 PropertyConverter 实现。 123456789101112131415161718192021222324252627282930313233343536373839// enum 转为 Integer@Entitypublic class User &#123; @Id private Long id; @Convert(converter = RoleConverter.class, dbType = Integer.class) private Role role; public enum Role &#123; DEFAULT(0), AUTHOR(1), ADMIN(2); final int id; Role(int id) &#123; this.id = id; &#125; &#125; public static class RoleConverter implements PropertyConverter&lt;Role, Integer&gt;; &#123; @Override public Role convertToEntityProperty(Integer databaseValue) &#123; if (databaseValue == null) &#123; return null; &#125; for (Role role : Role.values()) &#123; if (role.id == databaseValue) &#123; return role; &#125; &#125; return Role.DEFAULT; &#125; @Override public Integer convertToDatabaseValue(Role entityProperty) &#123; return entityProperty == null ? null : entityProperty.id; &#125; &#125;&#125; more 如果是在 entity 类中定义自定义转换器，那么该转换器应该为 static. 别忘记正确处理 null,通常如果 input 是 null，也应返回 null. 推荐使用基本数据类型，更易转换. 绝对不能在转换器中调用数据库(Box,BoxStore),转换器方法在事务中调用，例如读取或写入对象到 box 中将会失败。 为提高性能，ObjectBox 使用了对所有的转换器使用了唯一一个实例。请保证除默认无参构造方法外没有自定义其他构造方法。同时请保证线程安全，应为在 multiple entities 中可能涉及到并发. List/Array 类型可以使用转换器转换 List 类型。例如把 List 转为一条 String 的 JSON 数组.当前不支持 Array 转换器.查看特性实现进度Array Enums最佳实践: 不要持久化 enum 的 ordinal 或 name: 二者都不稳定，且在下次你修改 enum 定义时会改变 使用稳定的 ids: 在 enum 中定义自定义属性(integer,string) 都可以保证稳定。使用该特性作为你的持久化映射. 准备好应对未知: 定义一个 UNKNOWN 的 enmu 值。可以应对 null 或 unknown 值的情况。例如可以确保已经被移除的 enum 值不会导致 App 崩溃. 查询时的自定义类型QueryBuilder 是不关心自定类型的。请使用内置类型查询。]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-2-Object IDs]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-2-Object-IDs%2F</url>
    <content type="text"><![CDATA[Object 必须具有一个类型为 long 的属性.当然可以使用它的包装类 java.lang.Long,但是不建议使用包装类.其他类型的 ID ( UID 等)可以自由定义，查询等操作。 news vs. persisted entities当创建一个对象时，还没有存入，它们的 ID 是 0.一旦该对象存入，ObjectBox 将为该对象指定 ID.可以通过 put()返回值拿到该 ID. 所以在 ObjectBox 内部通常把 ID 作为一个状态指示器,如果为 0 表示新创建，不为 0 表示已经存储。关联特别依赖这个特性. 特殊的 Object IDsObject IDs 可能是任意 long 值，除了以下两种: 0: 或者当类型为 Long 时为 null,被认为是新创建，还未存储。put这个对象总是会插入一个新对象，并指定一个未使用过的 ID. 0xFFFFFFFFFFFFFFFF (-1 in Java): ObjectBox 保留。 ObjectBox 指定 ID对于每一个新对象，ObjectBox 把比当前 box 中最大的 ID 值大的未使用的值指定给新对象的 ID.比如 box 中有一个 ID 为 1 和 ID 为 100 的对象，那么新创建对象的 ID 将为 101. 默认只有 ObjectBox 可以指定 ID(👇 介绍).如果试图自己存入一个 ID 比当前 ID 值最大的还大的对象，ObjectBox 将抛出错误。 手动指定 IDs如果需要手动指定 ID,那么请添加如下注解: 12@Id(assignable = true)long id; 这将会允许存入任意值 ID 的对象。当然设置 ID 为 0 时，ObjectBox 将制定新 ID 自定义 ID 会打破自动状态指示监视(new vs. persisted). 所以应该立即存入该自定义 ID 对象，可能还得手动绑定 box，特别在关联状况下. ID 的 String 别名 (还在路上…)查看特性实现进度String ID alias]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-1-配置]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-1-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[手动添加依赖库如果 ObjectBox 插件没有自动添加依赖库和注解处理器，那么手动添加。 12345dependencies &#123; // all below should be added automatically by the plugin compile "io.objectbox:objectbox-android:$objectboxVersion" annotationProcessor "io.objectbox:objectbox-processor:$objectboxVersion"&#125; 1234567dependencies &#123; // all below should be added automatically by the plugin compile "io.objectbox:objectbox-android:$objectboxVersion" kapt "io.objectbox:objectbox-processor:$objectboxVersion" // some useful Kotlin extension functions compile "io.objectbox:objectbox-kotlin:$objectboxVersion"&#125; 改变 model 文件位置默认 model 文件位于 module-name/objectbox-models/default.json. 123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ "objectbox.modelPath" : "$projectDir/schemas/objectbox.json".toString() ] &#125; &#125; &#125;&#125; 12345kapt &#123; arguments &#123; arg("objectbox.modelPath", "$projectDir/schemas/objectbox.json") &#125;&#125; 改变 MyObjectBox 的包名默认 MyObjectBox 类包名和 entity 类或其父类的包名相同. 123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ "objectbox.myObjectBoxPackage" : "com.example.custom" ] &#125; &#125; &#125;&#125; 12345kapt &#123; arguments &#123; arg("objectbox.myObjectBoxPackage", "com.example.custom") &#125;&#125; 开启 debug 模式123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ 'objectbox.debug' : 'true' ] &#125; &#125; &#125;&#125; 12345kapt &#123; arguments &#123; arg("objectbox.debug", true) &#125;&#125; greenDAO 兼容查看greenDAO 兼容配置]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-12-事务]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E5%85%A5%E9%97%A8-12-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[ObjectBox 是一个满足 ACID 特性的交易型数据库.一个事务可以包含一组操作，要么执行成功，要么全部失败。几乎所有的 ObjectBox 的操作都包含了事务。比如 put(),read()。普通情况下，不用关心这些底层的事务。但某些复杂的情况下，手动处理事务操作可以使你的 app 更加高效一致。 手动事务ObjectBox 提供了如下方法实现手动事务： runInTx: 在事务中运行指定的 runnable runInReadTx: 在一个只读的事务中运行指定的 runnable.不同于写入事务，多个只读事务可以同时运行。 runInTxAsync: 在另一个线程中运行指定的 runnable.一旦事务执行完毕，callback(可为 null) 将被调用. callInTx: 类似 runInTx(Runnable),但是有返回值或抛出异常. 对批量存入操作进行手动事务的优势是你可以实现任意数量的操作，使用多个 box 对象。同时，在事务执行过程中，可以对数据有一个直观的认知。 1234567// 写入事务boxStore.runInTx(() -&gt; &#123; for (User user: allUsers) &#123; if (modify(user)) box.put(user); else box.remove(user); &#125;&#125;) 事务代价理解事务可以很好的帮助掌握数据库性能。请注意: 写入事务代价大.提交事务包含了将数据同步到物理存储中的操作，这对数据库是一个相对昂贵的操作。只有文件系统确认所有的数据都存储，事务操作才会被认为是成功的。事务同步该文件可能需要几毫秒。请记住：尽量把多个操作(put 等)放入同一个事务中. 12345678910// 不推荐for(User user: allUsers) &#123; modify(user); // modifies properties of given user box.put(user);&#125;// 推荐for(User user: allUsers) &#123; modify(user); // modifies properties of given user&#125;box.put(allUsers); 读取事务ObjectBox 的读取事务很快。相对于写入事务，没有 commit 操作，所以没有昂贵的同步文件系统。请注意：在一个读取事务中 put 操作是非法的，会抛出一个异常。get,count,queries 等操作没有手动声明事务(读写),默认会运行在一个读取事务.虽然读取事务比写入事务代价小，但是还是最好把它放入读取事务中。 多版本的并发ObjectBox 提供了语义化的多版本并发控制(Multiversion concurrency control MVCC).多个并发读取(读取事务)可以立即执行，无需阻塞或等待。这是通过存储多个版本的（提交）数据来实现的。即便一个写入事务正在运行，读取事务也可以立即获取到最新的同步状态。写入事务按顺序执行以便状态一致。所以保证写入事务短小可以避免阻塞其他写入事务。因此在一个写入事务中执行网络操作或复杂计算不推荐。尽量在写入事务前完成这些操作。 注意不需要自己手动维持写入事务序列。如果多线程想同时执行写入事务(put,runInTx),同一时刻只有一个线程可以执行，其他必须等待。类似 Java 中的 lock 或 synchronized。 深入写入事务尽量避免在写入事务中使用锁(synchronized 或 java.util.concurrent.locks).因为写入事务运行费时，所以 ObjectBox 内部会获取一个写入锁。当设计多个锁时，请提高警惕。始终以相同的顺序获取锁可以避免死锁。如果在一个事务获取了 X 锁，请保证你的代码在持有 X 锁时没有在另外一个写入事务中执行.]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-11-Data Browser]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E5%85%A5%E9%97%A8-11-Data-Browser%2F</url>
    <content type="text"><![CDATA[Data Browser 具有如下功能: 查看数据库的 entities 和 schema 下载 JSON 格式的 entities 配置1234567dependencies &#123; debugImplementation "io.objectbox:objectbox-android-objectbrowser:$objectboxVersion" releaseImplementation "io.objectbox:objectbox-android:$objectboxVersion"&#125;// apply the plugin after the dependencies blockapply plugin: 'io.objectbox' 不这样设置可能出现 Duplicate files copied in APK lib/armeabi-v7a/libobjectbox.so 这样的错误.因为 ObjectBox 插件又添加了一次 objectbox-android 库 在 AndroidManifest.xml 添加如下权限(2.2.0 后需要) 1234&lt;!-- Required to provide the web interface --&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;!-- Required to run keep-alive service when targeting API 28 or higher --&gt;&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE"/&gt; 建议在 Application 类中添加 12345boxStore = MyObjectBox.builder().androidContext(this).build();if (BuildConfig.DEBUG) &#123; boolean started = new AndroidObjectBrowser(boxStore).start(this); Log.i("ObjectBrowser", "Started: " + started);&#125;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-10-关联]]></title>
    <url>%2F2019%2F02%2F25%2FObjectBox%E5%85%A5%E9%97%A8-10-%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[Object 之间的关联具有方向性.关联是延迟初始化的：实际的引用对象只有在调用时才会从数据库中加载。一旦加载过，就会缓存起来. To-One 关联使用 ToOne 会智能的对目标对象创建关联。同时获取目标对象缓存。 12345678910111213141516// Customer.java@Entitypublic class Customer &#123; @Id public long id;&#125;// Order.java@Entitypublic class Order &#123; @Id public long id; public ToOne&lt;Customer&gt; customer;&#125;// 为了绑定 customer 对象，对 ToOne 实例调用 setTarget() 然后就存入 order 对象Customer customer = new Customer();Order order = new Order();order.customer.setTarget(customer);long orderId = boxStore.boxFor(Order.class).put(order); 如果 customer 在数据库中不存在，ToOne 将会存储。如果已经存在，那么 ToOne 只会创建关联,不会存储.如果关联 Entity 使用的是自定义 IDs(@Id(assignable = true)),则该 Entity 不会被存储. 在 ToOne 实例中，可通过 Order 对象的 getTarget() 获取 customer 12Order order = boxStore.boxFor(Order.class).get(orderId);Customer customer = order.customer.getTarget(customer); 如果只是想要获取 ID 而不是整个目标对象，getTargetId() 值得拥有，此方法根本不会接触数据库，所以高效。 移除关联: 仅移除关联关系，而不会从数据库中移除目标对象。 12order.customer.setTarget(null);boxStore.boxFor(Order.class).put(order); 查看 objectbox-models/default.json 会发现，ToOne 属性根本没有保存。仅仅只是目标对象的 ID 保存在一个名称和 ToOne 属性后拼接 Id 的虚拟属性. 初始化魔术注意到 ToOne 属性 customer 从没初始化，然而调用时却不会抛出空指针异常。因为该初始化已经执行过了。ObjectBox 插件会对 entity 类(仅支持纯 Java 项目和 Android 项目) 在调用前正确的初始化。所以在自定义构造方法时，你可以假设 ToOne/ToMany/List 属性已经初始化过了。 1234567891011121314@Entitypublic class Example &#123; ToOne&lt;Order&gt; order; ToMany&lt;Order&gt; orders; transient BoxStore __boxStore; public Example() &#123; // this.order = new ToOne&lt;&gt;(this, Example_.order); this.orders = new ToMany&lt;&gt;(this, Example_.orders); &#125; public Example(String value) &#123; this(); &#125;&#125; 提升性能为了提高性能，请提供全参数构造方法。对于 ToOne 属性，请添加一个名为 ToOne 属性名加 Id 的 id 参数。可以参考 objectbox-models/default.json 里的命名. 12345678910@Entitypublic class Order &#123; @Id public long id; public ToOne&lt;Customer&gt; customer; public Order() &#123; /* default constructor */ &#125; public Order(long id, long customerId /* virtual ToOne id property */) &#123; this.id = id; this.customer.setTargetId(customerId); &#125;&#125; ToMany 关联可以使用 List 或 ToMany 类型实现 ToMany 关联.相对 ToOne 来说，ToMany 可以实现追踪数据变化并将其写入操作中，而 List 必须自己实现. 1:N 使用 @Backlink 注解 1:N 关联属性。 123456789101112131415161718192021222324252627282930313233343536// Customer.java@Entitypublic class Customer &#123; @Id public long id; // 'to' is optional if only one relation matches @Backlink(to = "customer") public ToMany&lt;Order&gt; orders;&#125;// Order.java@Entitypublic class Order &#123; @Id public long id; public ToOne&lt;Customer&gt; customer;&#125;Customer customer = new Customer();customer.orders.add(new Order());customer.orders.add(new Order());long customerId = boxStore.boxFor(Customer.class).put(customer); // puts customer and ordersCustomer customer = boxStore.boxFor(Customer.class).get(customerId);for (Order order : customer.orders) &#123; // TODO&#125;Order order = customer.orders.remove(0);boxStore.boxFor(Customer.class).put(customer);// optional: also remove the order from its box// boxStore.boxFor(Order.class).remove(order); N:N 12345678910111213141516171819202122232425262728293031323334353637383940// Teacher.java@Entitypublic class Teacher&#123; @Id public long id;&#125;// Student.java@Entitypublic class Student&#123; @Id public long id; public ToMany&lt;Teacher&gt; teachers;&#125;Teacher teacher1 = new Teacher();Teacher teacher2 = new Teacher();Student student1 = new Student();student1.teachers.add(teacher1);student1.teachers.add(teacher2);Student student2 = new Student();student2.teachers.add(teacher2);// puts students and teachersboxStore.boxFor(Student.class).put(student1, student2);Student student1 = boxStore.boxFor(Student.class).get(student1.id);for (Teacher teacher : student1.teachers) &#123; // TODO&#125;student1.teachers.remove(0);// boxStore.boxFor(Student.class).put(student1);// more efficient than using put:student1.teachers.applyChangesToDb(); 上面可以通过 student 知道 teacher 的信息，当然可以反过来 1234567891011121314151617181920// Teacher.java@Entitypublic class Teacher&#123; @Id public long id; @Backlink(to = "teachers") // backed by the to-many relation in Student public ToMany&lt;Student&gt; students;&#125;// Student.java@Entitypublic class Student&#123; @Id public long id; public ToMany&lt;Teacher&gt; teachers;&#125; 更新关联ToOne 和 ToMany 可以追踪变化（只要存入拥有关联属性的 entity）并将其存入数据库中，如果 ID != 0 或者 @Id(assignable = true) 那么可以通过 Box 来更新关联 1234567// update a related entity using its boxOrder orderToUpdate = customer.orders.get(0);orderToUpdate.text = "Revised description";// DOES NOT WORK// boxStore.boxFor(Customer.class).put(customer);// WORKSboxStore.boxFor(Order.class).put(orderToUpdate); 更新 ToOneToOne 类提供了如下方法更新关联: setTarget(entity): 创建关联；传入 null 清除关联 setTargetId(entityId): 对存在的目标 entity 创建关联；传入 0 清除关联. setAndPutTarget(entity): 12order.customer.setTarget(customer); // or order.customer.setCustomerId(customer.getId());orderBox.put(order); 如果 entity 在调用 setAndPutTarget() 之前还没存储,那么需要先绑定它的 box 123Order order = new Order(); // new entityorderBox.attach(order); // need to attach box firstorder.customer.setAndPutTarget(customer); 如果目标 entity 使用自定义 IDs,必须在更新 ToOne 关联时存储它 1234customer.id = 12; // self-assigned idcustomerBox.put(customer); // need to put customer firstorder.customer.setTarget(customer); // or order.customer.setCustomerId(customer.getId());orderBox.put(order); 这是因为 ObjectBox 只保存 id 为 0 的关联对象. 更新 ToManyToMany 实现了 java.lang.List 接口。如果向 ToMany 实例添加对象，这些对象就会被存储进数据库。移除也一样。（仅仅是关联被移除而已）.不要忘记把追踪 ToMany 改变的 own entity 对象存储. 123customer.orders.add(order1);customer.orders.remove(order2);customerBox.put(customer); 如果使用自定义 IDs(@Id(assignable = true)) 请在修改 ToMany 前绑定它的 box 1234customer.id = 12; // self-assigned idcustomerBox.attach(customer); // need to attach box firstcustomer.orders.add(order);customerBox.put(customer); 如果 entity 是自定义 IDs,那么需要先存入该 entity,然后再更新关联并存储 own entity. 1234order.id = 42; // self-assigned idorderBox.put(order); // need to put order firstcustomer.orders.add(order);customerBox.put(customer); // put customer, add relation to order 树形关联可以使用 ToOne,ToMany 处理指向自身的树形关联 123456789@Entitypublic class TreeNode &#123; @Id long id; ToOne&lt;TreeNode&gt; parent; @BackLink ToMany&lt;TreeNode&gt; children;&#125; 生成的 entity 可以获取它的 parent 和 children 12TreeNode parent = entity.parent.getTarget();List&lt;TreeNode&gt; children = entity.children;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-9-订阅观察]]></title>
    <url>%2F2019%2F02%2F25%2FObjectBox%E5%85%A5%E9%97%A8-9-%E8%AE%A2%E9%98%85%E8%A7%82%E5%AF%9F%2F</url>
    <content type="text"><![CDATA[Data Observers, Reactive Extensions订阅观察模式，Rx 支持 1234Query&lt;Task&gt; query = taskBox.query().equal(Task_.complete,false).build();query.subscribe(subscriptions) .on(AndroidScheduler.mainThread()) .observer(data -&gt; updateUi(data)); Data Observers当数据改变时，ObjectBox 会通知所有的订阅者.他们可以订阅确定的数据类型(通过 BoxStore)或查询结果集。实现 io.objectbox.reactive.DataObserver 即可创建观察者 1234interface DataObserver&lt;T&gt; &#123; void onData(T data);&#125;| onData() 异步调用，不用关心线程 订阅普通改变123456DataObserver&lt;Class&lt;Task&gt;&gt; taskObserver = new DataObserver&lt;Class&lt;Task&gt;&gt;() &#123; @Override public void onData(Class&lt;Note&gt; data)&#123;&#125;&#125;;boxStore.subscribe(Task.class).observer(taskObserver);| subscribe() 会接受所有可用的对象类型改变通知。 订阅查询12Query&lt;Task&gt; query = taskBox.query().equal(Task_.completed, false).build();subscription = query.subscribe().observer(data -&gt; updateUi(data)); 取消订阅当调用 observer() 时，返回 io.objectbox.reactive.DataSubscription 1234interface DataSubscription &#123; void cancel(); boolean isCanceled();&#125; 1234DataSubscription subscription = boxStore.subscribe().observer(myObserver);// At some later point:subscription.cancel(); 通常情况下建议使用 DataSubscriptionList 123456789101112private DataSubscriptionList subscriptions = new DataSubscriptionList();protected void onStart() &#123; super.onStart(); Query&lt;X&gt; query = box.query()... .build(); query.subscribe(subscriptions)... .observe(...);&#125;protected void onStop() &#123; super.onStop(); subscriptions.cancel();&#125; 订阅，事务当事务提交时发出订阅通知。单独调用box.put(),remove() ，默认的事务会开启提交。例如如下将触发两次 User.class 通知； 12box.put(firendUser);box.put(myUser); 使用 runInTx(),callInTx() 可以将多个操作在同一个十五中提交.如上可以修改为: 1box.put(friendUser,myUser); 响应式扩展线程切换12Query&lt;Task&gt; query = taskBox.query().equal(Task_.complete, false).build();query.subscribe().on(AndroidScheduler.mainThread()).observer(data -&gt; updateUi(data)); 当然可以使用自定义 Looper 创建 AndroidScheduler,或者实现 io.objectbox.reactive.Scheduler 查询在后台线程执行 DataTransformer 运行在后台线程 DataObserver 和 ErrorObserver 运行在后台线程，除非通过 on() 指定 数据转换如何订阅实际的对象数量: 123boxStore.subscribe() .transform(clazz -&gt; return boxStore.boxFor(clazz).count()) .observer(count -&gt; updateCount(count)); 异常订阅transformer 可能抛出各种异常，DataObserver 可能抛出 RuntimeException. 123public interface ErrorObserver &#123; void onError(Throwable th);&#125; 在 subscribe() 后调用 onError() 即可. 一次通知 vs. 改变即通知当订阅 query 后，DataObserver 具有如下行为： 初始化查询结果(就在订阅后) 更新查询结果(在数据改变后) 有时候仅对其中一种行为感兴趣.single() 和 onlyChange() 应运而生(在 subscribe() 后调用)single() 只响应一次通知即自动取消。 弱引用一般情况下，为了避免内存泄露，通常尽可能在不需要的时候取消订阅。当然，你不在乎的话，在 subscribe() 后调用 weak() 也可以. ObjectBox RxJava 扩展库1implementation "io.objectbox:objectbox-rxjava:$objectboxVersion"]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-8-查询]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-8-%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Queries 使用 QueryBuilder 定义查询标准，Query 类运行查询并返回匹配结果 QueryBuilder QueryBuilder 使用编译生成的元信息类来指定要匹配的属性值。 1234567List&lt;user&gt; joes = userBox.query().equal(User_.firstName,"Joe").build().find();QueryBuilder&lt;User&gt; builder = userBox.query();builder.equal(User_.firstName,"Joe") .greater(User_.yearOfBirth,1970) .startsWith(User_.lastName,"O");List&lt;User&gt; youngJoes = builder.build().find(); 边界条件 equal(),notEqual(),greater(),less() isNull(),notNull() between() in(),notIn() startsWith(),endsWith(),contains() and(),or() 排序1234567userBox.query().equal(User_.firstName,"Joe") .order(User_.lastName) // 升序排列,忽略大小写 .find();userBox.query().equal(User_.firstName,"Joe") .order(User_.lastName,QueryBuilder.DESCENDING | QueryBuilder.CASE_SENSITIVE) .find(); Query1234567Query&lt;User&gt; query = builder. build();// 返回所有匹配的对象List&lt;User&gt; joes = query.find();// 返回第一个匹配的对象，如果不存在返回 nullUser joe = query.findFirst();// 返回唯一一个匹配的对象，如果不存在返回 null,如果有多个值抛出异常User joe = query.findUnique(); 如果是不断的执行 Query,那么应该缓存 Query 对象，重复使用。为了复用 Query 对象，可以改变它的属性值，或查询参数，或添加的各种边界条件。 12345// 假设已经构建了一个 Query 对象，但是为了后面复用，此处 equal 边界条件的值设置为 ""Query&lt;User&gt; query = userBox.query().equal(User_.firstName,"").build();// 接下来可以根据具体情况改变参数值List&lt;User&gt; joes = query.setParameter(User_.firstName,"Joe").find();List&lt;User&gt; jakes = query.setParameter(User_.firstName,"Jake").find(); 如果是多个边界条件，可以在边界条件后给每一个参数设置一个别名 1234// 给 equal() 查询参数设置 name 别名Query&lt;User&gt; query = userBox.query().equal(User_.firstName,"").parameterAlias("name");// 然后可以传入键值对来代替属性List&lt;User&gt; joes = query.setParameter("name","Joe").find(); Limit,Offset,Pagination12Query&lt;User&gt; query = userBox.query().equal(User_.firstName,"Joe").build();List&lt;User&gt; joes = query.find(/*offset*/10,/*limit*/5,/*results*/); 延迟加载 findLazy(),findLazyCached() 返回 LazyList 查询结果。 LazyList 是线程安全的，不可修改的只读 list,只有在访问时才会加载数据。缓存 LazyList 可以保留之前访问过的数据以避免重复加载。 删除query.remove() 删除所有匹配的结果 属性查询如果只想返回某个指定属性的值而不是匹配的全部对象列表，那么请使用 PropertyQuery.在构建 query 后调用 property(Property) 即可 123String[] emails = userBox.query().build() .property(User_.mail) .findStrings(); findString() 返回第一条结果，findStrings() 返回所有结果 返回的是没有排序的结果，即使在构建 query 时指定了排序规则. 处理 null 值默认不返回 null 值。如果属性为 null，可以指定一个替代返回值 12345// 如果 email 为 null,返回 unknownString[] emails = userBox.query() .property(UserBox_.mail) .nullValue("unknown") .findStrings(); distinct，unique12345// 返回 ‘joe'String[] names = userBox.query() .property(User_.firstName) .distinct() .findStrings(); 默认 strings 忽略大小写。当然可以定制 12345// 返回 'joe' 'Joe' 'JOE'String[] names = userBox.query() .property(User_.firstName) .distinct(StringOrder.CASE_SENSITIVE) .findStrings(); 只查询一个值，没有则抛出异常 1234String[] names = userBox.query().build().equal(User_.isAdmin, true) .property(User_.firstName) .unique() .findStrings(); distinct 和 unique 可以组合 统计属性查询同时提供了统计函数。 min(),minDouble() max(),maxDouble() sum,sumDouble(): sum() 可能溢出并抛出异常 avg(): 返回 double count(): 比查询到对象列表然后求列表长度要快。可以和 distinct() 组合 为关联属性添加查询条件创建关联属性后，可能想为只存在于关联 entity 的属性添加查询条件。SQL 中使用 JOIN. 12345678910111213@Entityclass Person &#123; @Id var id: Long = 0 var name: String? = null lateinit var address: ToManay&lt;Address&gt;&#125;@Entityclass Address &#123; @Id var id: Long = 0 var street: String? = null var zip: String? = null&#125; 查询住在指定街道(Address)的 xxx(Person)。可以使用link(RelationInfo 12345// 获取所有名为 elmo 的对象val builder = box.query().equal(Person_.name,"Elmo");// 住在 Sesame 街道builder.link(Person_.address).equal(Address_.street,"Sesame Street");val elmosOnSesameStreet = builder.build().find() 如果想获取到 Address 列表呢？那么可以在 Address 中添加 @Backlint 注解 1234567891011@Entityclass Address &#123; // ... @Backlint(to = "addresses") lateinit var persons: ToMany&lt;Person&gt;&#125;// 获取所有 Sesame 街道对象val builder = box.query().equal(Address_.street,"Sesame Street");// 名为 elmobuilder.link(Address_.persons).equal(Person_.name,"Elmo");val sesameStreetsWithElmo = builder.build().find(); 当然，也可以不用修改 Address,使用 backlink(RelationInfo) 即可实现查询 123val builder = box.query().equal(Address_.street,"Sesame Street");builder.backlink(Person_.address).equal(Person_.name,"Elmo");val sesameStreetWithElmos = builder.build().find(); 关系属性的激进加载默认关系属性是懒加载的。第一次访问 ToOne ,ToMany 属性时会到数据库中查询数据，然后都会使用缓存过的数据。 12val customers = customerBox.query().build().find()customers[0].orders[0]; // 第一次访问触发数据库查询 如果想在查询结果返回时实现预读取 ToOne,ToMany 数据,请使用 QueryBuilder.eager 1234val customers = customerBox.query() .eager(Customer_.orders) .build() .find(); eager 加载仅支持一层深度。如果有嵌套的关联层级，可以使用下面的 query filter 实现。 query filters应用于复杂的边界条件，QueryBuilder 类不能实现。使用如下规则将会非常高效： 使用标准的数据库边界条件缩小目标范围。(使用 QueryBuilder 获取目标) 然后使用 QueryFilter 过滤QueryFilter 一次检查一个目标对象，符合返回 true 12345// 缩小范围songBox.query().equal(Song_.bandId,bandId) .filter((song) -&gt; &#123; return song.starCount * 2 &gt; song.downloads; &#125;); 关注一下性能: ObjectBox 创建对象非常快 虚拟机会回收短期对象。此处回收将比创建快，所以性能不是问题。 query filters 和 ToManyToMany 提供了很多函数可以方便的转为 query filters: hasA hasAll getById]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-7-kotlin支持]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-7-kotlin%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Kotlin 支持kotlin Entity 在 kotlin 中，ID 属性应该这样定义 @Id var id: Long = 0.ID 必须是 var. 构造器 ObjectBox 优先调用全参的构造方法。如果自定义属性或 transient 属性 或关联属性是构造方法的一部分参数，ObjectBox 将不会调用此构造方法.所以应该提供为这些参数提供默认值以确保无参构造方法存在。 1234567@Entitydata class Note( @Id var id: Long = 0, val text: String = "", @Convert( converter = StringsConverter::class, dbType = String::class) val strings: List&lt;String&gt; = listOf()) kotlin Entity 中定义关联属性在 kotlin 中定义关联属性可能比较麻烦。但请注意：关联属性必须为 var. 否则 initialization magic 将不起作用.通常可以使用 lateinit 修饰关联属性 123456789101112@Entityclass Order &#123; @Id var id: Long = 0 lateinit var customer: ToOne&lt;Customer&gt;&#125;@Entityclass Customer &#123; @Id var id: Long = 0 @Backlink( to = "customer") latelinit var orders: List&lt;Order&gt;&#125; kotlin 扩展函数123dependencies &#123; implementation "io.objectbox:objectbox-kotlin:$objectboxVersion"&#125; kotlin 12345678910111213val box: Box&lt;DataClassEntity&gt; = store.boxFor()val query = box.query &#123; equal(property,value) order(property)&#125;val query = box.query().inValues(property,array).build()toMany.applyChangesToDb(resetFirst = true) &#123; // 默认 false add(entity) removeById(id)&#125;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-6-Java桌面应用.md]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-6-Java%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java 桌面应用嵌入式数据库ObjectBox 不仅仅适用于 Android 项目，同时也适用于运行在 Windows Linux macOS 上的纯 Java(JVM) 桌面应用. 配置请使用 Gradle 作为构建工具，因为 ObjectBox 使用了 Gradle 插件. 1234567891011121314151617buildscript &#123; ext.objectboxVersion = '2.3.3' repositories &#123; jcenter() maven&#123; url "https://plugins.gradle.org/m2/"&#125; &#125; dependencies &#123; classpath "net.ltgt.gradle:gradle-apt-plugin:0.20" classpath "io.objectbox:objectbox-gradle-plugin:$objectboxVersion" &#125;&#125;repositories &#123; jcenter()&#125;apply plugin: 'java'apply plugin: 'net.ltgt.apt-idea' // 注解处理器插件apply plugin: 'io.objectbox' Native 库ObjectBox 是由 C/C++写成的可以运行大多数 native code 的对象数据库。 改变 Model 文件位置默认 model 文件存储在 module-name/objectbox-models/default.json.可以通过修改 objectbox.modelPath 来改变 1234// 在项目 build.gradle 文件， apply plugin: 'java' 之后添加tasks.withType(JavaCompile) &#123; options.compilerArgs += ["-Aobjectbox.modelPath=$projectDir/schemas/object.json]&#125; 改变 MyObjectBox 包名123tasks.withType(JavaCompile) &#123; options.compilerArgs += [ "-Aobjectbox.modelPath=$projectDir/schemas/objectbox.json" ]&#125; 开启 debug 模式12345678// enable debug output for pluginobjectbox &#123; debug true&#125;// enable debug output for annotation processortasks.withType(JavaCompile) &#123; options.compilerArgs += [ "-Aobjectbox.debug=true" ]&#125; 可以使用 BoxStore builder 的 name(String) 来改变数据库存储的位置。单元测试添加 junit 4 库]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-5-LiveData]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-5-LiveData%2F</url>
    <content type="text"><![CDATA[LiveData (Arch.Comp.)从 1.2.0 开始支持 Android Architecture ComponentsObjectBox 提供 ObjectBoxLiveData 可以在 ViewModel 中使用 1234567891011public class NoteViewModel extends ViewModel &#123; private ObjectBoxLiveData&lt;Note&gt; noteLiveData; public ObjectBoxLiveData&lt;Note&gt; getNoteLiveData(Box&lt;Note&gt; notesBox) &#123; if (noteLiveData == null) &#123; // 查询所有的 notes, text 按 a-z 的顺序排列 noteLiveData = new ObjectBoxLiveData(notesBox.query().order(Note_.text).build()); &#125; return noteLiveData; &#125;&#125; 上一种方法需要传入 Box.可以使用 AndroidViewModel 代替，它可以访问 Application context,然后会在 ViewModel 中调用 ((App)getApplication()).getBoxStore().boxFor().第一种的优势在于没有引用 Android 类，所以可以进行单元测试。 1234567NoteViewModel model = ViewModelProviders.of(this).get(NoteViewModel.class);model.getNoteLiveData(notesBox).observe(this,new Observer&lt;List&lt;Note&gt;&gt;&#123; @Override public void onChanged(@Nullable List&lt;Node&gt; notes) &#123; notesAdapter.setNotes(notes); &#125;&#125;) Paging (Arch.Comp.)从 2.0.0 开始支持.ObjectBox 提供了 ObjectBoxDataSource 类.它继承了 paging 库的 PositionalDataSource在 ViewModel 中，类似创建 LiveData,先创建 ObjectBox query.然后构造并使用 ObjectBoxDataSource 工厂代替 LiveData. 1234567891011121314public class NotePageViewModel extends ViewModel &#123; private LiveData&lt;PagedList&lt;Note&gt;&gt; noteLiveDataPaged; public LiveData&lt;PagedList&lt;Note&gt;&gt; getNoteLiveDataPaged(Box&lt;Note&gt; notesBox) &#123; if(noteLiveDataPaged == null) &#123; Query&lt;Note&gt; query = notesBox.query().order(Note_.text).build(); noteLiveDataPaged = new LivePagedListBuilder( new ObjectBoxDataSource.Factory(query), 20 // 页数 ).build(); &#125; return noteLiveDataPaged; &#125;&#125;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-4-本地单元测试]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-4-%E6%9C%AC%E5%9C%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[安卓本地单元测试设置测试环境| 此配置仅针对 ObjectBox 1.4 及之前版本.新版本已经自动添加了 native ObjectBox 依赖库。 123456789// /app/build.gradledepdendencies &#123; // 必备 JUnit 4 testImplementation 'junit:unit:4.12' // 手动添加平台独立的 native Objectbox 依赖库.(可选) testImplementation "io.objectbox:objectbox-linux:$objectboxVersion" testImplementation "io.objectbox:objectbox-macos:$objectboxVersion" testImplementation "io.objectbox:objectbox-windows:$objectboxVersion"&#125; | 本地单元测试仅支持 64 位系统.| windows 可能需要安装 Microsoft Visual C++ 2015 Redistributable(x64) 创建本地单元测试类 可以使用 BoxStore builder 的directory(File) 指定数据库保存在本地设备上。 为保证数据不交叉污染，可以使用 BoxStore.deleteAllFiles(File) 删除已经存在的数据库 12345678910111213141516171819202122232425262728293031public class NoteTest &#123; private static final File TEST_DIR = new File("objectbox-example/test-db"); private BoxStore store; @Before public void setUp() throws Exception &#123; // 删除之前的数据库 BoxStore.deleteAllFiles(TEST_DIR); store = MyObjectBox.builder() // 指定数据库存放路径 .directory(TEST_DIR) // 添加 debug 标记打印日志 .debugFlags(DebugFlags.LOG_QUERIES | DebugFlags.LOG_QUERY_PARAMETERS) .build(); &#125; @After public void tearDown() throws Exception &#123; if (store != null) &#123; store.close(); store = null &#125; BoxStore.deleteAllFiles(TEST_DIR); &#125; @Test public void exampleTest() &#123; Box&lt;Note&gt; noteBox = store.boxFor(Note.class); assertEquals(...); &#125;&#125; 关系测试 ObjectBox 1.4.4 及之后 为了测试具有 ToOne,ToMany 属性的 entity,必须在本地 JVM 初始化 entity 并且添加一个 transient 的 BoxStore 属性.]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-3-注解]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-3-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Entity 注解entity 数据可访问 ObjectBox 需要访问 entity 的属性(生成 Cursor 类). 属性包内可见。kotlin 中使用 JvmField 提供标准 getters 为了提升性能，请提供具有全部属性的构造方法 123456789101112@Entitypublic class User &#123; @Id private long id; private String name; @Transient private int tempUsageCount; public User()&#123;/* 默认构造方法 */&#125; public User(id,name)&#123; this.id = id; this.name = name; &#125; // getters and setters for properties...&#125; entity 属性的注解 @NameInDb 可以在数据库中为属性命名。 应该使用 @Uid 注解来代替重命名属性和 entity @NameInDb 仅支持内联常量来指定列名。 @Transient 保证属性不被持久化，transient，static 修饰符也一样. 属性索引 @Index @Index 当前不支持 byte[] float double Index typs(String). ObjectBox 2.0 引入了 index types.之前对每一个索引，使用属性的值来完成查询。现在 ObjectBox 可以使用 hash 来生成 index.由于 String 属性明显比标量值更占空间，ObjectBox 对 strings 使用默认的 index type 完成 hash.可以针对 String 类型的属性明确指定 index type 为基于值构建索引。 12@Index( type = IndexType.VALUE)private String name; 请注意：对于 String 类型的属性，基于值的索引可能比默认基于 hash 的索引更占空间,这种结论取决于该值的长度。 ObjectBox 支持以下索引属性: 未指定或默认: 根据属性的类型决定(HASH for String,VALUE for others) VALUE: 使用属性值生成索引。例如 String,可能更占空间 HASH: 使用属性值的 32 位 hash 生成索引。偶尔可能发生 hash 碰撞，但实际概率很小。通常比 HASH64 更佳，因为占空间小 HASH64: 使用属性值的长 hash 生成索引。比 HASH 占空间大，所以一般情况下不是首选. Unique 约束如果 unique 约束的属性值冲突，put() 操作将被终止且抛出 UniqueViolationException 的异常.Unique 基于 Index,所以可以同时给属性添加 @Index 注解。 关系]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-2-基本操作]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Entity在一个类中至少需要 @Entity 和 @Id 两个注解才能定义一个 ObjectBox model.例如: 123456// User.java@Entitypublic class User &#123; @Id public long id; public String name;&#125; 然后 make 就可生成 model. | @Id 的类型必须为 long.| 如果 entity 发生了很大的变动（如移动类或修改注解）,必须 rebuild 项目以便 ObjectBox 生成的代码得到更新. 核心类 MyObjectBox: 基于 entity 类生成。提供 builder 配置 BoxStore. BoxStore: ObjectBox 的入口。操作数据库，管理 Boxes 的工具. Box: 对 entity 保存和查询。每一个 entity 都有一个对应的 Box（由 BoxStore 提供). 核心初始化实例化 BoxStore 的最好时机是在 app 启动时。推荐在 Application 类的 onCreate 方法中进行. 12345678910111213public class App extends Application &#123; private BoxStore boxStore; @Override public void onCreate() &#123; super.onCreate(); boxStore = MyObjectBox.builder().androidContext(this).build(); &#125; public BoxStore getBoxStore() &#123; return boxStore; &#125;&#125;// 然后在 app 生命周期内就可以使用了notesBox = ((App) getApplicationi()).getBoxStore().boxFor(User.class); Box 基本操作 put: 存入一个对象，可能会覆盖具有相同 ID 的对象。即使用 put 插入或更新对象。返回 ID。 get,getAll: 提供一个对象的 ID，可快速的通过 get获取它。getAll 获取指定的所有的对象。 remove,removeAll: 从 box 中删除一个对象。removeAll 删除指定的所有对象. count: 返回该 box 存储的对象数量. query: 返回一个 query builder. Object IDs Entity 必须具有一个类型为 long,由 @Id 注解属性。当然可以使用可空的 java.lang.Long类型，但不推荐。如果需要使用另外一种类型的 ID(服务器返回的 String 类型的 UID),把它作为普通属性即可，然后可以通过此 ID 查询. 123456@Entity class StringIdEntity &#123; @Id priavte long id; private String uid;&#125;StringIdEntity entity = box.query().equal(StringIdEntity_.uid,uid).findUnique(); 指定 IDObjectBox 默认会为新对象指定 IDs.ID 自增. 12345User user = new User();// user.id == 0box.put(user);// user.id != 0long id = user.id 如果插入的对象的 ID 比 box 里的 ID 最大值还大，ObjectBox 将抛出错误. 保留 Object IDsObject IDs 不能：– 0,null(使用 java.lang.Long)。– 0xFFFFFFFFFFFFFFFF（java 中的 -1）:内部保留 事务 put 运行在隐式事务中 优先使用 put 批量操作列表 （put(entities)） 如果在循环中操作大量数据，考虑明确使用事务，如runInTx()]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-1-简介]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-1-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[关于ObjectBox 定位是: 针对移动端和 IoT 超快的 (superfast edge database) 面向对象的数据库 .为小型设备提供了边缘计算能力，使得数据可以快速高效地在本地存储、处理、安全管理.ObjectBox 小于 1MB,最适合移动 APP、小型 IoT 设备及路由。并且 ObjectBox 也是第一个在边缘设备上兼容 ACID 的高性能的 NoSQL 数据库.所有的产品都是基于工程师思维开发的，所以可以使用最少的代码去实现想要的功能。 优点 比同类竟品快 10 倍以上。BenchMark 跨平台。支持 Linux、Windows、Mac/iOS、Android、Raspberry Pi、ARM 等嵌入式设备和容器。 小于 1MB,特别针对小型设备设计和优化。 易使用。 支持 reactive. 无缝结合 greenDAO.(同一家公司出品) 更好地支持关系型数据. 提供了改变追踪(change tracking)，级联添加(cascading puts)，灵活的加载策略(eager,lazy) 无需掌握 SQL:ObjectBox 设计简单，使用方便，不需要掌握 SQL 即可上手. 支持 kotlin: 包括 data class. 使用Android(Java)123456789101112// root 目录 build.gradlebuildscript &#123; ext.objectboxVersion = '2.3.3' repositories &#123; jcenter() &#125; dependencies &#123; // Android Gradle plugin 最低版本为 3.0.0 classpath 'com.android.tools.build:gradle:3.3.1' classpath "io.objectbox:objectbox-gradle-plugin:$objectboxVersion" &#125;&#125; 123// app 或其他 module build.gradleapply plugin: 'com.android.application'apply plugin: 'io.objectbox' 放在最下面 Android(Kotlin)12345// app 或其他 module build.gradleapply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-kapt' 如果使用 kotlin-android 插件，必须加 kotlin -kapt 插件apply plugin: 'io.objectbox' 放在最下面 Sync gradle 即可自动添加 ObjectBox 依赖. 配置1、首先添加 ObjectBox 插件.2、如果 ObjectBox 插件没有自动添加依赖库和注解处理器，请手动添加依赖。 123456// Android(Java)// /app/build.gradledependencies &#123; compile "io.objectbox:objectbox-androoid:$objectboxVersion" annotationProcessor "io.objectbox:objectbox-processor:$objectboxVersion"&#125; 12345678// Android(kotlin)// /app/build.gradledependencies &#123; compile "io.objectbox:objectbox-android:$objectboxVersion" kapt "io.objectbox:objectbox-processor:$objectboxVersioni" // 针对 kotlin 的扩展函数(可选) compile "io.objectbox:objectbox-kotlin:$objectboxVersion"&#125; 3、改变 Model 文件的路径 ObjectBox Model 文件默认保存在 module-name/objectbox-models/default.json。 1234567891011// Android(Java)// /app/build.gradleandroid &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = ["objectbox.modelPath":"$projectDir/schemas/objectbox.json".toString()] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app/build.gradlekapt &#123; arguments &#123; arg("objectbox.modelPath":"$projectDir/schemas/objectbox.json") &#125;&#125; 4、改变 MyObjectBox 的包名 MyObjectBox 类的包名默认和 entitiy 类的包名或其上一级报名一致。 1234567891011// Android(Java)// /app/build.gradleandroid &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = ["objectbox.myObjectBoxPackage":"com.example.custom"] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app/build.gradlekapt &#123; arguments &#123; arg("objectbox.myObjectBoxPackage", "com.example.custom") &#125;&#125; 5、开启 Debug 模式 在 /app/build.gradle 中添加必要的选项后，运行 ./gradlew --info 即可查看 debug 输出 1234567891011// Android(Java)// /app/build.gradleandroid &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = ['objectbox.debug' : 'true'] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app/build.gradlekapt &#123; arguments &#123; arg("objectbox.debug", true) &#125;&#125; 6、开启 DaoCompat 兼容模式 从 greenDAO 迁移过来，生成和 greenDAO 相似的 API,使 ObjectBox 看起来就像 SQLite 一样。 1234// /app[module]/build.gradledepdendencies &#123; compile "org.greenrobot:objectbox-daocompat:1.10"&#125; 然后开启 DaoCompat 模式 1234567891011// Android(Java)// /app[module]/build.gradleandroid &#123; defaultConfig &#123; javaCOmpileOptions &#123; annotationProcessorOptions &#123; arguments = ['objectbox.daoCompat':'true'] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app[module]/build.gradlekapt &#123; arguments &#123; arg("objectbox.daoCompat":true) &#125;&#125; 如果你计划从 greenDAO 迁移到 ObjectBox,那么你可能会保留原来的 greenDAO entity 类（复制这些类到另外的包中）然后按如下修改。 首先改变注解。请注意：不是所有的 greenDAO 注解都支持无缝迁移到 ObjectBox,支持的如下： 1234567// greenDAOimport org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation...// ObjectBoximport io.objectbox.annotation.Entity;import io.objectbox.annotation... ObjectBox 当前不支持 unique indexes,naming indexes,或者在多个属性间 indexes. 1234567// greenDAO@Entity(indexes = ...)@Index(name = "idx1", unique = true) private String name;@Unqiue private String name;// ObjectBox@Index private String name; 自定义类型。修改父类,当然也可同时继承，这样该自定义类型就可同时在 greenDAO 和 ObjectBox 间使用 12345// greenDAOimport org.greenrobot.greendao.converter.PropertyConverter;// ObjectBoximport io.objectbox.converter.PropertyConverter; 修改 @Convert 注解里的 columnType 改为 dbType 12345// greenDAO@Convert(converter = NoteTypeConverter.class, columnType = String.class)// ObjectBox@Convert(converter = NoteTypeConverter.class, dbType = String.class) 关系。ObjectBox 使用 ToOne 和 ToMany类型替代 greenDAO 的 @ToOne 和 @ToMany 注解。 使用 BoxStore.修改完 entity 后，设置 BoxStore 创建 DaoSession. 123456789// 通常在 Application 类中boxStore = MyObjectBox.builder().androidContext(this).build();daoCompatSession = new DaoSession(boxStore);// 在迁移完成后，你可能想移除这些迁移操作。// 那么通过 greenDAO session 获取 entities,把他们转为 ObjectBox entities,// 然后使用 DaoCompat session 插入。List&lt;com.example.app.daos.greendao.Note&gt; notes = daoSession.getNoteDao().loadAll();List&lt;Note&gt; convertedNotes = convertToObjectBoxNotes(notes);daoCompatSession.getNoteDao().insertInTx(convertedNotes); 默认没有设置 ID (即 id == 0),ObjectBox 会为插入的数据生成一个新的 ID.如果想保留原来的 ID,请修改 @Id(assignable = true) 使用 DaoCompat DaoSession在使用新 compat session 替换原来的 API 后，可以通过在 Application 类中的一个方法返回 DaoSession 123456public DaoSession getDaoSession() &#123; // greenDAO // return daoSession; // ObjectBox return daoCompatSession;&#125; 表面上 compat DaoSession 是 greenDAO DaoSession 的替代品，其实它内部是使用 BoxStore 代替了 greenDAO 数据库.如果还使用了 greenDAO 的额外特性，比如 queries,那么还需如下修改: 123456// greenDAOimport org.greenrobot.greendao.query.Query;import org.greenrobot.greendao...// ObjectBoximport org.greenrobot.daocompat.query.Query;import org.greenrobot.daocompat... QueriesDaoCompat 支持以下的 Query 功能:– remove() 替代 DeleteQuery– count() 替代 CountQuery– 不支持 CursorQuery DaoCompat 和 greenDAO 的不同– 不支持 NotNull– 不支持 Joins 和 原生 SQL 查询.– 不支持异步 sessions: startAsyncSession()– 不支持加密– 仅支持简单的 AbstractDaoTest 和 AbstractDaoBasicTest]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
