<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JGit]]></title>
    <url>%2F2019%2F03%2F16%2FJGit%2F</url>
    <content type="text"><![CDATA[前言JGit 是一个基于 EDL(BSD 协议的变种)授权的轻量级、实现 Git 版本控制系统功能(常规仓库访问,网络协议,版本控制核心算法)的纯 Java 库. 入门获取在仓库搜索引擎中搜索 jgit 即可获取各种添加依赖的方式.我现在基本使用的是 gradle 依赖 12implementation("org.eclipse.jgit:org.eclipse.jgit:5.3.0.201903130848-r")implementation("org.eclipse.jgit:org.eclipse.jgit.http.server:5.3.0.201903130848-r") JGit 也具有 CLI(功能比 git CLI 少),可以试一下 JGit 的功能. 手动编译 JGit CLI假设已经 clone EGit 仓库. git clone https://git.eclipse.org/r/jgit/jgit.git 具体查看 12345678~/src/jgit$ mvn clean install# 进入 jgit 可执行文件所在文件夹org.eclipse.jgit.pgm/target/jgit# 查看 version 命令prompt$ ./jgit versionjgit version xxxxx# 如果经常使用 jgit 命令,可以添加执行链接(通常在 /usr/local/bin)sudo ln -s /path/to/jgit /usr/local/bin/jgit 在 JGit CLI 运行命令1234567891011121314151617181920prompt$ ./git# 会列出最常用的命令jgit --git-dir GIT_DIR --help (-h) --show-stack-trace command [ARG ...]The most commonly used commands are: branch List, create, or delete branches clone Clone a repository into a new directory commit Record changes to the repository daemon Export repositories over git:// diff Show diffs fetch Update remote refs from another repository init Create an empty git repository log View commit history push Update remote repository from local refs rm Stop tracking a file tag Create a tag version Display the version of jgit # 常用的 debug test 命令 prompt$ ./jgit debug-show-commands 查看仓库在查看最常用的命令之前，你可能想知道该仓库包含了多少分支，当前分支是那个.使用 branch -v 可以获取所有分支的简略信息，版本号，版本号提交信息的第一行. 12345678910111213prompt$ ./jgit branch -v# master 4d4adfb Git Project import: don't hide but gray out existing projects# * traceHistory 6b9fe04 [historyView] Add trace instrumentation# 和 git-log 一样 log 命令显示提交信息jgit log --author Math --grep tycho master# 显示 master 分钟中，作者名包含 Math,提交信息包含 tycho 的搜有提交信息.# commit xxxx# Author: Math xxxx# Date: xxx# Update build to use tycho x.xx.x# ...# 大多数的搜索都会精确过滤提交日志，如提交者姓名等 历史图形化jgit glog 核心概念API仓库Repository 管理所有的项目和引用，管理代码 12345val repository = FileRepositoryBuilder() .setGitDir(File("/my/git/directory")) .readEnvironment() // 扫描 GIT_* 环境变量 .findGitDir() // 扫描文件系统 .build() Git 对象在 Git object model 所有的对象都是由 SHA-1 id 表示.在 JGit 中是由 AnyObjectId 和 ObjectId类表示.在 Git object model 中定义了四种对象类型: blob: 用于存储文件对象 tree: 可以看作一个文件夹，指向其他的 tree 或 blob commit: 指向一个 tree 的提交信息 tag: 突出提交信息,通常用来标记特殊的 release 版本. 为了从一个仓库中识别一个对象，只要传入一个正确的 revision 字符串即可 1val head = repository.resolve("HEAD") Refref 是一个包含单个对象标识符的变量.对象标识符可以是任何 Git 合法对象(blob,tree,commit,tag)例如,获取 head 的引用. 1val HEAD = repository.findRef("refs/heads/master") RevWalkRevWalk 遍历 commit graph，并按顺序生成匹配的 commit 1val revWalk = RevWalk(repository) RevCommitRevCommit 表示 Git object model 中的一个 commit 1val commit = walk.parseCommit(objectIdOfCommit); RevTagRevCommit 表示 Git object model 中的一个 Tag 1val tag = walk.parseCommit(objectIdOfTag); RevTreeRevCommit 表示 Git object model 中的一个 tree 1val tree = walk.parseCommit(objectIdOfTree); 参考虽然 JGit 包含了许多和 Git 仓库交互的低级代码，同时还有一些参考org.eclipse.jgit.apit包中 Git porcelain 命令的高级 API. 添加命令(git-add)add 命令可以向索引中添加文件，同时可以通过 setter 方法配置 addFilepattern() 1234val git = Git(repository)git.add() .addFilepattern("/dir") .call() 提交命令(git-commit) setAuthor() setCommitter() setAll() 1234git.commit() .setAuthor("author","email") .setMessage("message") .call() tag 命令(git-tag) setName() setMessage() setTagger() setObjectId() setForceUpdate() setSigned(): 暂不支持，会抛异常 123git.tag() .setName("tag") .call() log 命令(git-log) add(AnyObjectId start) addRange(AnyObjectId since,AnyObjectId until) 123git.log() .add(head) .call() merge 命令(git-merge)TODO Ant 任务]]></content>
  </entry>
  <entry>
    <title><![CDATA[teamcity自动化更新hexo博客]]></title>
    <url>%2F2019%2F03%2F09%2Fteamcity%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言在知乎找到了一个更好的方法: 原文在这里我整理一下: 创建仓库 xxx.github.io. 创建两个分支: master/hexo.(可在 github 网页或本地创建) git clone git@github.com:xxx/xxx.github.io.git 如果没有在网页创建分支,可以在此处创建.git checkout -b master; git checkout -b hexo 接下来执行 npm install hexo; hexo init; npm i; npm i hexo-deployer-git,此处在 hexo 分支操作 修改 _config.yml 的 deploy 参数,此处在 master 分支操作. 我使用了hexo-next-theme,从 git 上下载后,进入 themes/next 执行 git submodule init,将 next 主题关联,此处在 hexo 分支操作 git add .; git commit -m &quot;blahblahblah&quot;; git push origin hexo; 提交网站相关文件. hexo g -d 生成网站并部署到 github. 将 CNAME,图片等文件放入 source 目录下,可保证推送到 github 不会被删除.⚠️ 👇 胡扯,观看请谨慎!!!TeamCity 是 Jetbrains 公司出品的持续化集成工具，类似Jenkins,界面更加现代化，功能更强大,而且它的 server 和 agent 是分离的，可以指定本机或远程的机器来运行构建策略，其中还有调度队列算法.hexo 是静态博客生成工具.hexo d -g命令可以自动生成 public 文件夹及 HTML，然后将其推送到 github(在_config.yml中已经配置过).一般用户可能对theme自定义(修改theme下的_config.yml),当换机或备份时，希望将博客源文件(*.md)及修改的主题配置文件一并备份.而hexo默认只备份public文件夹,所以本文探索使用 CITeamCity将推送到Github的源文件编译生成public文件,这样每次写完文章,只要将其推送到Github,TeamCity会自动生成博客HTML. 获取到该 Key.而实际上在 build 执行时 key 以 ing 被删除了,不可能获取到.这并不意味着绝对安全，只是增加了 key 被盗的难度. agent 必须安全. teamcity 安装TeamCity提供了 Docker安装方式，因此请提前安装好Docker.文件目录如下(请提前创建),teamcity 支持多种数据存储方式，此处使用 mysql 来存储。 123456789101112# - teamcity - agent - conf - data - server - data - datadir - opt - mysql - backup - data dockery-compose.yml 接下来是docker-compose.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162``yamlversion: "3.3"services: teamcity-server: image: jetbrains/teamcity-server container_name: teamcity-server restart: always ports: - 8111:8111 volumes: - $PWD/server/datadir:/data/teamcity_server/datadir - $PWD/server/opt/logs:/opt/teamcity/logs - $PWD/server/data:/data/teamcity_server/others # 其他的一些资源，可以从本机复制到 server 上 environment: # TEAMCITY_SERVER_MEM_OPTS: -Xmx2g -XX:MaxPermSize=270m -XX:ReservedCodeCacheSize=350m MYSQL_USER: team-user MYSQL_PASSWORD: team-pwd MYSQL_ROOT_PASSWORD: teamcity8080 MYSQL_DATABASE: teamcitydb depends_on: - db links: - db networks: - team db: image: mysql container_name: teamcity-db restart: always volumes: - $PWD/mysql:/etc/mysql/conf.d - $PWD/mysql/backup:/var/lib/mysql # 只有 /var/lib/mysql 对应本地文件为空，才会创建这个数据库,即初次创建时，这个对应的本地文件夹要为空 - $PWD/mysql/data:/others environment: MYSQL_USER: team-user MYSQL_PASSWORD: team-pwd MYSQL_ROOT_PASSWORD: teamcity8080 MYSQL_DATABASE: teamcitydb ports: - 3306:3306 networks: - team # &lt;&gt;&lt;&gt; agent &lt;&gt;&lt;&gt; teamcity-agent: image: jetbrains/teamcity-agent container_name: teamcity-agent restart: always volumes: - $PWD/agent/conf:/data/teamcity_agent/conf - $PWD/agent/data:/data/teamcity_agent/others environment: AGENT_NAME: MacbookPro SERVER_URL: http://xxx.xxx.x.xxx:8111 # 此处对应的是 TeamCityServer 的IP, localhost/127.0.0.1 都不行，请使用正确的 IP,端口对应上面暴露出来的端口 links: - teamcity-server # teamcity_agent 默认的任务环境路径: opt/buildagent/worknetworks: team: driver: bridge 然后执行 docker-compose up -d 即可。 需要先根据本机 OS 安装docker-compose &gt; docker-compose up -d 生成服务docker-compose down 解体服务，删除容器,网络docker-compose start/stop 启动终止服务 打开 http://localhost:8111 或 http://[ip]:8111 即可进入 TeamCity Server web 交互环境.按照提示初始化.登录时默认没有访客创建新用户的权限，所以需要已超级用户权限登录，点击下面的以超级权限登录后提示输入 token,可以进入 TeamCity Server 本地映射文件中查找，或是使用 docker logs teamcity-server 即可看到 token。 创建项目时，TeamCity 默认使用用户名密码连接 Github,当然可以通过上传本地 ssh key 密钥到 TeamCity Server,通过 TeamCity Server 连接. 设置编译步骤,我再次执行了shell 脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#! /bin/bash# 安装 nodejsVERSION=v10.15.2DISTRO=linux-x64function checkNode() &#123; ISNODESUCCEED=$(node -v) if [ ISNODESUCCEED != $VERSION ]; then installNode else echo "NodeJS已安装" fi&#125;function insallNode() &#123; mkdir -p /usr/local/lib/nodejs tar -xJf /data/teamcity_agent/others/node-$VERSION-$DISTRO # -v 会输出解压日志，此处太多，所以关闭 export PATH=/usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin:$PATH source ~/.profile checkNode&#125;checkNode# 安装依赖npm i# 生成public文件./node_modules/hexo/bin/hexo g# 为 github.io 配置 CNAMEif [ ! -f "/CNAME" ]; then echo "blog.dang8080.cn" &gt; CNAMEfi# 配置 gitgit config --global credential.helper store # 保存 github 提交者信息，下次不用再输密码git config --global user.name "Humphrey"git config --global user.email "dang8080@qq.com"git add --allgit commit -m "TeamCity CI 提交部署: $(date)"git push origin master 问题: 所以问题来了,配置完了点击 run 查看 Build log 会发现 push 失败。因为通过 https 向 github 提交代码需要交互式输入用户密码。而此处没有提供，将密码硬编码到此 shell 里提交到 github 也不安全。或者即使是通过修改 VCS root 使用 git@github.com ssh checkout 的代码，也无法推送到 github. 问题定位: TeamCity SSH agent 使用本机(Linux/MacOS)的 OpenSSH 管理 SSH,对于 Windows,需要手动安装 OpenSSH (CygWin,MinGW,Git for Windows).SSH agent 必须添加到 $PATH 中.第一次连接到远程地址时，SSH agent 会询问是否保存远程地址的 fingerprint 到地址数据库 ~/.ssh/known_hosts中.为了避免询问，可以提前配置。如果相信该远程地址，可以禁用远程地址检查 对所有的连接都禁用，~/.ssh/config 123Host \*StrictHostKeyChecking no 特定连接,-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no TeamCity 当前仅支持 PEM 格式的 key.如果使用了其他格式的 key，请将其转换为 PEM.可以在 TeamCity web 界面 Conversions -&gt; Export OpenSSH key 中转换. OpenSSH 最近版本默认不生成 PEM 格式 key.使用下列方式生成 PEM: ssh-keygen -t rsa -m PEM 上传到 TeamCity Server 的 SSH key 默认保存在 &lt;TeamCity Data Directory&gt;/config/projects/&lt;project&gt;/pluginData/ssh_keys，TeamCity 会追踪此文件夹保证 SSH key 更新。SSH key 适用于本项目及子项目. 在 TeamCity agent checkout 执行时，Git 插件会从 TeamCity Server 下载 SSH key 到 agent.该 key 会暂时保存在 TeamCity agent 的文件系统里，在 fetch/clone 结束后就被删除. key 被删除的原因是：通过 build 执行的 test 可能会留下恶意代码，之后会访问 TeamCity agent 文件系统, TeamCity 是不支持 git ssh 推动代码到 github 的.（支持 ssh 传送文件） 方案一:当 run 一次之后，执行 docker exec -it teamcity-agent bash 进入 opt/buildagent/work/xxxxx/ 下,手动 git push origin master。这样后续就不用再配置了 方案二:(硬核)github 需要保存本机的 SSH pub key,才接受 git ssh 推送.那我们就在 TeamCity 生成 ssh key,然后添加到 github. 实践一1234docekr exec -it teamcity-agent bashssh-keygen -t rsassh-add [id_rsa]# 然后复制 id_rsa.pub 的内容到 github 即可 实践二连 TeamCity agent bash 也不想进，使用 shell 构建先安装 expect tcl tk 123456789101112131415161718192021222324apt-get update &amp;&amp; apt-get install tcl tk expect# 下面是 shell#! /usr/bin/expect -fset context $PWD# 删除旧keyspawn rm -f "$context/id_rsa" "$context/id_rsa.pub"expect&#123;&#125;# 生成新keyspawn ssh-keygen -t rsaexpect&#123; "*save the key*" &#123; send "$context/id_rsa\r";exp_continue &#125; "*passphrase*" &#123; send "\r";exp_continue &#125; "*again*" &#123; send "\r" &#125;&#125;spawn ssh-add "$context/id_rsa"sshcheck=$(ssh -vT git@github.com)if [[ $sshcheck =~ "successfully authenticated" ]]; then echo "ssh 配置成功"else echo "ssh 配置失败"fi# 复制 pubpubkey=$(cat "$context/id_rsa)curl -H "Content-Type:application/json" -X POST --data '&#123; "title":"TeamCityAgentAuto","key":"$pubkey"&#125;']]></content>
      <tags>
        <tag>teamcity</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Room & kotlin coroutine]]></title>
    <url>%2F2019%2F03%2F03%2FRoom-kotlin-coroutine%2F</url>
    <content type="text"><![CDATA[OverviewRoom 2.1 开始支持 Kotlin 协程。DAO 方法可以使用 suspend 标记以确保这些方法不会在主线程中被执行。Room 使用 Executor(来自框架组件) 作为 Dispatcher 运行 SQL 语句，当然在编译 RoomDatabase 时，你也可以提供自己的 Executor. 当前协程支持正在开发中，更多特性正在计划中 添加依赖请升级 Room 到 v2.1, 同时 Kotlin v1.3.0+ , Coroutines v1.0.0+ 1implementation "androidx.room:room-coroutines:$&#123;versions.room&#125;" 现在就可以使用啦 123456789101112131415161718@Daointerface UsersDao &#123; @Query("SELECT * FROM users") suspend fun getUsers(): List&lt;User&gt; @Query("UPDATE users SET age = age + 1 WHERE userId = :userId) suspend fun incrementUserAge(userId: String) @Insert suspend fun insertUser(user: User) @Update suspend fun updateUser(user: User) @Delete suspend fun deleteUser(user: User)&#125; 在调用其他 suspending DAO 函数时，@Transaction 也可以被 suspending 123456789101112131415@Daoabstract class UsersDao &#123; @Transaction open suspend fun setLoggedInUser(loggedInUser: user) &#123; deleteUser(loggedInUser) insertUser(loggedInUser) &#125; @Query("DELETE FROM users") abstract fun deleteUser(user: User) @Insert abstract suspend fun insertUser(user: User)&#125; 根据是否在 transaction 内调用，Room 对 suspending 函数处理逻辑不同. 在 Transaction 中 在数据库语句被触发的 CoroutineContext 下，Room 不做任何处理。函数调用者应该确保此方法不会在 UI 线程中执行.因为 suspend 函数只能被其他 suspend 函数 或在 coroutine 内调用，所以你不能把 Dispatchers.Main 赋值给 Dispatcher，应该是 Dispatchers.IO 或自定义 不在 Transaction 中 Room 会确保数据库语句在 Architecutre Components I/O Dispatcher 中触发。该 Dispatcher 在同一个 I/O Executor 的一个后台线程中运行 LiveData 底层12345@Insertfun insertUserSync(user: User)@Insertsuspend fun insertUser(user: User) 对于同步 insert,生成的代码开始启动一个 transaction,然后执行 insert,标记 transaction successfull ，终结。同步方法在被调用处的线程执行. 12345678910@Overridepublic void insertUserSync(final User user) &#123; __db.beginTransaction(); try &#123; __insertionAdapterOfUser.insert(user); __db.setTransactionSuccessful(); &#125; finally &#123; __db.endTransaction(); &#125;&#125; suspending 会确保不会在 UI 线程中执行。生成的代码会传递一个 Continuation.在 Callable#call() 中执行和同步相同的代码 1234567891011121314151617@Overridepublic Object insertUserSuspend(final User user, final Continuation&lt;? super Unit&gt; p1) &#123; return CoroutinesRoom.execute(__db, new Callable&lt;Unit&gt;() &#123; @Override public Unit call() throws Exception &#123; __db.beginTransaction(); try &#123; __insertionAdapterOfUser.insert(user); __db.setTransactionSuccessful(); return kotlin.Unit.INSTANCE; &#125; finally &#123; __db.endTransaction(); &#125; &#125; &#125;, p1);&#125; CoroutinesRoom.execute 会根据数据库是否 open,当前调用是否在 transaction 内来切换处理 context. is open &amp; in transaction 仅调用 insert 逻辑 not in transaction 使用 Architecture Components IO Executor 在后台线程执行 insert 逻辑]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Room</tag>
        <tag>Kotlin</tag>
        <tag>Kotlin 协程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker,docker-compose学习笔记]]></title>
    <url>%2F2019%2F03%2F01%2Fdocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[OverviewCompose 是一个为了定义和运行多容器 Docker 应用的工具。官方动手示例 特性 一个主机多个隔离环境 当容器创建时保留所有的 volume 只有容器被更改时才触发创建 定义变量和在不同环境中使用 使用场景 自动测试环境 单独主机部署 docker-compose 安装1234sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composesudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composesudo docker-compose --version pip 安装 1pip install docker-compose 卸载 12sudo rm /usr/local/bin/docker-composepip uninstall docker-compose docker-compose 命令 -f 指定 一个或多个 compose 文件的名称和路径 1、使用多个 Compose 文件时，Compose 会把这几个文件合并为一个配置。按顺序合并，后边的覆盖前边的配置。2、docker-compose -f docker-compose.yml -f docker-compose.admin.yml run backup_db3、使用 -(dash) 作为 -f 的值，将会从输入中读取配置文件名。使用 stdin 时，配置里涉及到的路径都是相对于当前工作上下文路径。4、如果不是用 -f,Compose 遍历当前上下文路径和它的父路径查询 docker-compose.yml 和 docker-compose.override.yml 文件。请至少提供一个 docker-compose.yml 文件。如果所有的文件都在同一个文件夹下，Compose 将合并它们。5、docker-compose.override.yml 的配置高于 docker-compose.yml,且为后者提供额外的配置属性。 为单独的 Compose 文件指定路径 1、使用 -f, 或从命令行输入，或在 shell / 某个环境配置文件中设置 COMPOSE_FILE 环境变量,指定不在当前文件夹的 Compose 文件路径.2、docker-compose -f ~/sandbox/rails/docker-compose.yml pull db 从 ~/sandbox/rails/docker-compose.yml 文件中获取 db 服务中定义的 postgres db 镜像。 -p 指定项目名 1、如果不指定 -p,Compose 默认使用当前文件夹的名称。 配置环境变量 docker-compose CLI 环境变量默认内置了几个环境变量可以配置 docker-compose.以 DOCKER_ 开头的变量和配置 docker 命令行客户端的变量类似。如果使用 docker-machine的话，eval &quot;$(docker-machine env my-docker-vm)&quot;将为变量设置正确的值。 COMPOSE_PROJECT_NAME 1、设置项目名.该值在启动时会作为容器服务的前缀.比如项目名 myapp,包含两个服务 db 和 web,那么 Compose 启动的容器名为 myapp_db_1 和 myapp_web_1.2、默认时项目文件夹的根目录名。 COMPOSE_FILE 1、指定 Compose 文件路径。如果未指定，Compose 将在当前文件夹查询 docker-compose.yml 文件，如果不存在将继续遍历父目录直到找到。2、支持使用文件路径分隔符(Linux &amp; MacOS [:] Windows [;]).比如 COMPOSE_FILE=docker-compose.yml:docker-compose.prod.yml,路径分隔符可以通过 COMPOSE_PATH_SEPARATOR 自定义 COMPOSE_API_VERSION 1、Docker API 仅支持来自指定版本客户端的请求。使用 docker-compose 时出现 client and server don&#39;t have same version 错误，那么可以通过设置该变量解决。2、设置该变量主要针对临时的运行客户端和服务端版本不一致的情况。 DOCKER_HOST 1、为 docker daemon 设置 URL.和 docker 客户端一样，默认为 unix:///var/run/docker.sock DOCKER_TLS_VERIFY 1、设置空字符以外的任何值时，开启 TLS. DOCKER_CERT_PATH 1、配置 ca.pem,cert.pem,key.pem 的路径。默认 ~/.docker COMPOSE_HTTP_TIMEOUT 1、超时时间(秒).默认 60s COMPOSE_TLS_VERSION 1、TLS 版本.默认 TLSv1. 可供选项 TLSv1, TLSv1_1, TLSv1_2 COMPOSE_CONVERT_WINDOWS_PATH 1、是否开启把 Windos-style 的路径转为 Unix-style 的卷定义。在 Windos 上使用 Docker Machine 和 Docker Toolbox 时总是要设置该变量。默认 0。 true/1 代表开启，false/0 代表关闭. COMPOSE_PATH_SEPARATOR 1、如果设置，COMPOSE_FILE 值将使用此处的定义作为分隔符。 COMPOSE_FORCE_WINDOWS_HOST 1、如果设置，即使 Compose 运行在 Unix-based 系统上，卷定义也将使用简略语法解析为假设运行在 Windows 上的路径。true/a,false/0 COMPOSE_IGNORE_ORPHANS 1、如果设置，Compose 不会试着对项目的单独容器检测。true/1,false/0 COMPOSE_PARALLEL_LIMIT 1、并行执行的限制。默认 64，绝不能低于 2. COMPOSE_INTERACTIVE_NO_CLI 1、如果设置，Compose 不会尝试使用 Docker CLI 和 run exec 操作交互。true/1,false/0 Compose fileversion 3build配置选项在编译期生效。build 可以指定一个路径 1234version: "3"services: webapp: build: ./dir 或者是一个在指定 context 下的路径对象，同时可包含 Dockerfile 和 args 12345678version: "3"services: webapp: build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 如果同时也指定了 image,Compose 使用 webapp 和 image 中指定的可选的 tag 命名最终生成的镜像名 12build: ./dirimage: webapp:tag swarm mode 不支持。docker stack 命令只接受预编译的镜像. CONTEXT可以是包含 Dockerfile 文件的路径，或 git 仓库的 url.如果是相对路径，那么被解析为相对于当前 Compose 文件的路径。此文件夹同时也是发送到 Docker daemon 的编译上下文。 DOCKERFILE可选此处必须指定编译路径 ARGS只有在编译过程中可访问的环境变量。首先，在 Dokcerfile 中指定参数: 12345ARG buildnoARG gitcommithashRUN echo "Build number: $buildno"RUN echo "Bashed on commit: $gitcommithash" 然后在 build 下给该参数复制（可以是键值对列表）： 1234567891011build: context: . args: buildno: 1 gitcommithash: cdc3b19build: context: . args: - buildno=1 - gitcommithash=cdc3b19 你也可以不指定值，它的值就是编译时 Compose 当前运行环境的值. YAML 布尔值(true,false,yes,no,on,off)应该使用引号应用，这样解析器才能把它们解析为 string CACHE_FROM v3.2+ 指定 engine 可以缓存的镜像列表 12345build: context: . cache_from: - alpine:latest - corp/webapp:3.14 LABELS v3.3+ 向生成的镜像添加元数据。可以是数组或目录推荐使用反向 DNS 标记以避免和其他软件冲突 12345678910111213build: context: . labels: com.example.description: "Accounting webapp" com.example.department: "Finance" com.example.label-with-empty-value: ""build: context: . labels: - "com.example.description=Accounting webapp" - "com.example.department=Finance" - "com.example.label-with-empty-value" SHM_SIZE v3.5+ 设置编译生成容器 dev/shm&#39; 分区大小。int 值单位为 byte. string 可以携带单位 1234567build: context: . shm_size: '2gb'build: context: . shm_size: 10000000 TARGET v3.4+ 编译 Dockerfile 中定义的指定版本 123build: context: . target: prod cap_add,cap_drop添加或删除容器的容量。man 7 capabilities 查看可用列表 12345cap_add: - ALLcap_drop: - NET_ADMIN - SYS_ADMIN swarm mode 无效 cgroup_parent为容器指定可选的 cgroup parent 1cgroup_parent: m-executor-abcd swarm mode 无效 command覆盖默认的命令 1command: bundle exec thin -p 3000 也可以是列表 1command: ["bundle", "exec", "thin", "-p", "3000"] configsTips 共享文件夹，卷，绑定挂载 如果你的项目不在 Users目录(cd ~),那么你需要共享驱动器或 Dockerfile 所在位置和当前正在使用的卷。如果出现运行时错误表示文件未找到，那么就是一个挂载卷的请求被拒绝，或服务启动失败，试着共享文件或驱动。挂载卷要求共享项目不在 C:\Users (Windows),或 /Users (Mac) 的驱动，并且如果是运行在 Dokcer Desktop for Windows 的 Linux 容器上的所有应用都需要共享。 如果改变了一个服务的 Dockerfile 或者编译文件夹里的内容，运行 docker-compose build重新编译 官方示例Compose &amp; WordPress 为项目创建空文件夹。该文件夹作为应用的上下文，且只保存构建镜像所需的资源。 创建 docker-compose.yml 1234567891011121314151617181920212223242526272829version: "3.3"services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - "8000:80" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: &#123;&#125;# db_data 卷会保存任何 WordPress 对数据库的改变。# WordPress 通常开放 80 和 443 端口. docker-compose up -d. 如果使用 Docker Machine, 那么运行 docker-machine ip MACHINE_VM 获取运行地址。如果是 destop 版，http://localhost 即可. docker-compose down 移除容器，默认的网络，保留 WordPress 和数据库。docker-compose down --volumes 全部移除。]]></content>
      <tags>
        <tag>docker</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]-LiveData with SnackBar,Navigation and other events(the SingleLiveEvent case)]]></title>
    <url>%2F2019%2F02%2F28%2F%E8%AF%91-LiveData-with-SnackBar-Navigation-and-other-events-the-SingleLiveEvent-case%2F</url>
    <content type="text"><![CDATA[原文 view(activity/fragment) 和 ViewModel 交流的比较好的方式是 LiveData observables. view 订阅 LiveData 的改变且随时响应。这适用于连续不断的显示在一个屏幕的数据。但是某些数据却更应该被消费一次，比如 Snackbar 消息，navigation 事件 或 dialog 触发器。与其试着通过扩展 Architecture Components 扩展或库解决这个问题，不如我们可以直面这是个设计缺陷。我们推荐你把你的事件看作是状态的一部分。本文我们将列举一些常见的错误和推荐的解决方案。 ❌ Bad: 1. 对事件使用 LiveData在 LiveData 对象内部直接持有 Snackbar 消息或 navigation 信号。原则上普通的 LiveData 对象可以这样使用，但实际上会暴露一些问题。在 master/detail 架构的 app 中，如下是 maters 的 ViewModel 12345678910// 请不要对事件这样用class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Boolean&gt;() val navigateToDetails : LiveData&lt;Boolean&gt; get() = _navigateToDetails fun userClicksOnButton() &#123; _navigateToDetails.value = true &#125;&#125; 在 View(activity/fragment) 中 123myViewModel.navigateToDetails.observe(this,Observer &#123; if (it) startActivity(DetailsActivity....)&#125;) 此方案的不足在于 _navigateToDetails将会一直为 true,而且不可能回到首屏: 用户点击按钮启动 Details Activity 用户按返回按钮，回到主 Activity 当 activity 进入回退栈时 observers 失活，现在再次激活 从 ViewModel 中调用 navigation 且立即将其设为 false 1234fun userClicksOnButton() &#123; _navigateToDetails.value = true _navigateToDetails.value = false&#125; 但是请注意： LiveData 保存数据但不会保证在接受到事件时发送任何数据。例如，当没有观察者活跃时更新值，那么一个新值将替换原来的值。同时，从不同线程设置属性将会导致竞争状态，此时仅能保证一个观察者被调用。 最主要的问题是，这个方案很难理解而且代码垃圾。所以我们如何保证在 navigation 事件发生时值重置？ ❌Better: 2.使用 LiveData wrapper 事件，在观察者中重置属性.123456listViewModel.navigateToDetails.observe(this,Observer &#123; if (it) &#123; myViewModel.navigateToDetailsHandled() startActivity(DetailsActivity...) &#125;&#125;) 1234567891011121314class ListViewModel: ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Boolean&gt;() val navigateToDetails: LiveData&lt;Boolean&gt; get() = _navigateToDetails fun userClicksOnButton() &#123; _navigateToDetails.value = true &#125; fun navigateToDetailsHandled() &#123; _navigateToDetails.value = false &#125;&#125; 此方案的不足之处在于有些冗余代码 ✅ ok：使用 SingleLiveEventSingleLiveEvent 只适用于部分场景。只发送和更新一次状态的 LiveData 12345678910class ListViewModel: ViewModel &#123; private val _navigateToDetails = SingleLiveEvent&lt;Any&gt;() val navigateToDetails: LiveData&lt;Any&gt; get() = _navigateToDetails fun userClicksOnButton() &#123; _navigateToDetails.call() &#125;&#125; 123myViewModel.navigateToDetails.observe(this, Observer &#123; startActivity(DetailsActivity...)&#125;) 123456789101112131415161718192021222324252627282930313233343536373839// SingleLiveEventpublic class SingleLiveEvent&lt;T&gt; extends MutableLiveData&lt;T&gt; &#123; private static final String TAG = "SingleLiveEvent"; private final AtomicBoolean mPending = new AtomicBoolean(false); @MainThread public void observe(LifecycleOwner owner, final Observer&lt;T&gt; observer) &#123; if (hasActiveObservers()) &#123; Log.w(TAG, "Multiple observers registered but only one will be notified of changes."); &#125; // Observe the internal MutableLiveData super.observe(owner, new Observer&lt;T&gt;() &#123; @Override public void onChanged(@Nullable T t) &#123; if (mPending.compareAndSet(true, false)) &#123; observer.onChanged(t); &#125; &#125; &#125;); &#125; @MainThread public void setValue(@Nullable T t) &#123; mPending.set(true); super.setValue(t); &#125; /** * Used for cases where T is Void, to make calls cleaner. */ @MainThread public void call() &#123; setValue(null); &#125;&#125; 此方案的不足之处在于只有一个订阅者。如果你有多个观察者，那么只有一个被调用且不保证顺序。 ✅ 推荐：使用 Event Wrapper1234567891011121314151617open class Event&lt;out T&gt;(private val content: T) &#123; val hasBeenHandled = false private set // 只读属性 /** * 返回 content, 阻止其再次调用 fun getContentIfNotHandled(): T? &#123; return if (hasBeenHandled) &#123; null &#125; else &#123; hasBeenHandled = true content &#125; &#125; fun peekContent(): T = content&#125; 1234567891011class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;() val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt; get() = _navigateToDetails fun userClicksOnButton(itemId: String) &#123; _navigateToDetails.value = Event(itemId) // Trigger the event by setting a new Event as a new value &#125;&#125; 1234567891011class ListViewModel : ViewModel &#123; private val _navigateToDetails = MutableLiveData&lt;Event&lt;String&gt;&gt;() val navigateToDetails : LiveData&lt;Event&lt;String&gt;&gt; get() = _navigateToDetails fun userClicksOnButton(itemId: String) &#123; _navigateToDetails.value = Event(itemId) // Trigger the event by setting a new Event as a new value &#125;&#125; 此方案的优势是用户需要使用 getContentIfNotHandled() 或 peekContent()指定意图。此方法把事件抽象为 state 的一部分：变成仅表示是否被消费的消息。 结论总之，把事件作为状态的一部分。使用这个 EventObserver 在大量事件结束后移除它 1234567class EventObserver&lt;T&gt;(private val onEventUnhandledContent: (T) -&gt; Unit) : Observer&lt;Event&lt;T&gt;&gt; &#123; override fun onChanged(event: Event&lt;T&gt;?) &#123; event?.getContentIfNotHandled()?.let &#123; value -&gt; onEventUnhandledContent(value) &#125; &#125;&#125; 123inline fun &lt;T&gt; LiveData&lt;Event&lt;T&gt;&gt;.observeEvent(owner: LifecycleOwner, crossinline onEventUnhandledContent: (T) -&gt; Unit) &#123; observe(owner, Observer &#123; it?.getContentIfNotHandled()?.let(onEventUnhandledContent) &#125;)&#125;]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>LiveData</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LiveData]]></title>
    <url>%2F2019%2F02%2F28%2FLiveData%2F</url>
    <content type="text"><![CDATA[LiveData 的优势 确保 UI 和数据状态匹配 LiveData 遵循观察者模式。 无内存泄漏 不会因为 Activity 被终止而崩溃 如果观察者处于 inactive 状态，例如 activity 处于回退栈中，那么它不会接收到任何 LiveData 事件. 不用手动处理生命周期事件 时刻更新数据状态 如果一个观察者的变为 inactive，那么它会在重新 active 时获取最新的数据状态。比如，一个 activiy 如果处于后台，那么它将在重新返回前台时获取到最新的数据。 应对 configuration change 如果一个 activity 或 fragment 由于 configuration change(设备旋转) 导致重新创建，它会立即获取最新可用的数据. 共享资源 可以使用单例模式扩展 LiveData，封装系统服务在 app 内共享。 在 ViewModel 对象中保存可以更新 UI 的 LiveData 对象，而不是在 activity 或 fragment 的原因是： 避免 activty 或 framgent 过度膨胀。UI controller 仅负责展示数据而不是保存数据状态 从特性的 activity 或 fragment 中剥离 LiveData 实例，使得 LiveData 对象可以在 configuration change 中存活。 请在主线程中调用 setValue(T) 更新 LiveData 对象.如果是在工作线程，请调用 postValue(T).]]></content>
      <tags>
        <tag>Architecture Components</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-6-元模型,IDs,UIDs]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-6-%E5%85%83%E6%A8%A1%E5%9E%8B-IDs-UIDs%2F</url>
    <content type="text"><![CDATA[不像 SQLite 这样的数据库，ObjectBox 不需要你创建 database schema.这不意味着 ObjectBox 是无 schema 的。为高效起见，ObjectBox 对存储的数据维护了一个元模型(meta model)。此元模型实际上等价于 ObjectBox 的 schema.它包含了所有属性的类型、indexes 等.不同之处在于 ObjectBox 试图自动管理该元模型.某些情况下，这需要你帮忙. Object 的 IDs 是 @Id 定义的，而 所有 entity 类型的实例都绑定一个 meta model ID. JSON for consistent IDsObjectBox 把一部分元模型保存在 JSON 文件中.此文件应该通过版本控制软件管理,主要原因是：它可以保证 元模型里的 IDs 和 UIDs 跨设备一致.]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-5-更新数据模型]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-5-%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[ObjectBox 大多数情况下自动管理数据模型.当添加/删除 entities 或属性时，ObjectBox 自动作出响应。对于其他改变如 保留或改变类型，ObjectBox 需要额外信息。 UIDsObjectBox 通过 unique IDs(UIDs) 来追踪 entities 和属性的变化。所有的 UIDs 都存储在 module-name/objectbox-models/default.json 中,可以使用版本控制软件(git)进行管理。 简单来说: 为了使 UID 相关的改变生效，在这些 entity 或 属性上放置 @Uid 然后编译，在获取进一步提示。 重命名 entities 和 属性需要 UID 注解的原因是: 如果仅仅改变 entities 和属性的名字，ObjectBox 只会意识到 old entity 不见了，而创建了新的 entity.所以告诉 ObjectBox 重命名 entity 和数据，而不是丢弃它们.它们是相同的一个 entity。实际上是在内部给 entity 绑定一个 UID.属性也一样. 实践第一步: 为想要重命名的 entity/属性添加空的 @Uid 注解 123@Entity@Uidpublic class MyName &#123; ... &#125; 第二步: 编译项目，然后会输出错误信息：给出当前 entity/属性的 UID 123error: [ObjectBox] UID operations for entity "MyName": [Rename] apply the current UID using @Uid(6645479796472661392L) - [Change/reset] apply a new UID using @Uid(4385203238808477712L) 第三部: 把上面的 UID 复制到 @Uid() 里 123@Entity@Uid(6645479796472661392L)public class MyName &#123; ... &#125; 第四步: 重命名吧 123@Entity@Uid(6645479796472661392L)public class MyNewName &#123; ... &#125; 或者可以在 default.json 中找到 UID,然后直接使用到 @Uid() 上，重命名即可 修改属性类型想要修改属性类型，那么 ObjectBox 内部得创建一个新类型。因为 ObjectBox 不会迁移数据。 重命名属性类型：这样该属性就会被认为是新属性(如果该属性已经有 @Uid 注解了，则行不通) 1234// old:String year;// new:int yearInt; 告诉 ObjectBox 对新属性使用新 UID. 实践一下第一步：对想修改类型的属性添加 @Uid 注解 12@UidString year; 第二步: 编译获取错误信息 123error: [ObjectBox] UID operations for property "MyEntity.year": [Rename] apply the current UID using @Uid(6707341922395832766L) - [Change/reset] apply a new UID using @Uid(9204131405652381067L) 第三步：为该属性应用新 @Uid,并修改类型. 12@Uid(9204131405652381067L)int year;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-4-entity继承]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-4-entity%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[ObjectBox 允许子类继承 entity 父类持久化的属性。同样也支持继承非 entity 类。1.4+ 也支持多继承.对于父类来说可以使用 @BaseEntity. 无注解: 类本身及其属性不需要持久化 @BaseEntity: 属性在子类中持久化，类本身不持久化 @Entity: 属性在子类中持久化，类本身也持久化 123456789101112131415161718192021222324252627282930// base class:@BaseEntitypublic abstract class Base &#123; @Id long id; String baseString; public Base() &#123; &#125; public Base(long id, String baseString) &#123; this.id = id; this.baseString = baseString; &#125;&#125;// sub class:@Entitypublic class Sub extends Base &#123; String subString; public Sub() &#123; &#125; public Sub(long id, String baseString, String subString) &#123; super(id, baseString); this.subString = subString; &#125;&#125; 1234567891011121314// entities inherit properties from entities@Entitypublic class SubSub extends Sub &#123; String subSubString; public SubSub() &#123; &#125; public SubSub(long id, String baseString, String subString, String subSubString) &#123; super(id, baseString, subString); this.subSubString = subSubString; &#125;&#125; 使用前注意 在继承链中可能存在由 @BaseEntity 注解的类，它们的属性将被忽略，不会成为 entity model 的一部分 不推荐继承一个仅含有 ID 属性的 base entity 类. 某些情况下可以使用 interface 更简单明了 限制 @BaseEntity 注解的父类不能成为 library 的一部分。 没有多态查询(例如查询父类却希望得到子类) 当前无论是 @Entity 还是 @BaseEntity 注解的父类，都不能使用 ToOne ToMany 关联]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-3-自定义类型]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[ObjectBox 支持以下类型（Java）: 1234567891011boolean, Booleanint, Integershort, Shortlong, Longfloat, Floatdouble, Doublebyte, Bytechar, Characterbyte[]StringDate 转换器注解和属性转换使用 @Convert 注解将其他类型属性转为内置属性。此处需要提供 PropertyConverter 实现。 123456789101112131415161718192021222324252627282930313233343536373839// enum 转为 Integer@Entitypublic class User &#123; @Id private Long id; @Convert(converter = RoleConverter.class, dbType = Integer.class) private Role role; public enum Role &#123; DEFAULT(0), AUTHOR(1), ADMIN(2); final int id; Role(int id) &#123; this.id = id; &#125; &#125; public static class RoleConverter implements PropertyConverter&lt;Role, Integer&gt;; &#123; @Override public Role convertToEntityProperty(Integer databaseValue) &#123; if (databaseValue == null) &#123; return null; &#125; for (Role role : Role.values()) &#123; if (role.id == databaseValue) &#123; return role; &#125; &#125; return Role.DEFAULT; &#125; @Override public Integer convertToDatabaseValue(Role entityProperty) &#123; return entityProperty == null ? null : entityProperty.id; &#125; &#125;&#125; more 如果是在 entity 类中定义自定义转换器，那么该转换器应该为 static. 别忘记正确处理 null,通常如果 input 是 null，也应返回 null. 推荐使用基本数据类型，更易转换. 绝对不能在转换器中调用数据库(Box,BoxStore),转换器方法在事务中调用，例如读取或写入对象到 box 中将会失败。 为提高性能，ObjectBox 使用了对所有的转换器使用了唯一一个实例。请保证除默认无参构造方法外没有自定义其他构造方法。同时请保证线程安全，应为在 multiple entities 中可能涉及到并发. List/Array 类型可以使用转换器转换 List 类型。例如把 List 转为一条 String 的 JSON 数组.当前不支持 Array 转换器.查看特性实现进度Array Enums最佳实践: 不要持久化 enum 的 ordinal 或 name: 二者都不稳定，且在下次你修改 enum 定义时会改变 使用稳定的 ids: 在 enum 中定义自定义属性(integer,string) 都可以保证稳定。使用该特性作为你的持久化映射. 准备好应对未知: 定义一个 UNKNOWN 的 enmu 值。可以应对 null 或 unknown 值的情况。例如可以确保已经被移除的 enum 值不会导致 App 崩溃. 查询时的自定义类型QueryBuilder 是不关心自定类型的。请使用内置类型查询。]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-2-Object IDs]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-2-Object-IDs%2F</url>
    <content type="text"><![CDATA[Object 必须具有一个类型为 long 的属性.当然可以使用它的包装类 java.lang.Long,但是不建议使用包装类.其他类型的 ID ( UID 等)可以自由定义，查询等操作。 news vs. persisted entities当创建一个对象时，还没有存入，它们的 ID 是 0.一旦该对象存入，ObjectBox 将为该对象指定 ID.可以通过 put()返回值拿到该 ID. 所以在 ObjectBox 内部通常把 ID 作为一个状态指示器,如果为 0 表示新创建，不为 0 表示已经存储。关联特别依赖这个特性. 特殊的 Object IDsObject IDs 可能是任意 long 值，除了以下两种: 0: 或者当类型为 Long 时为 null,被认为是新创建，还未存储。put这个对象总是会插入一个新对象，并指定一个未使用过的 ID. 0xFFFFFFFFFFFFFFFF (-1 in Java): ObjectBox 保留。 ObjectBox 指定 ID对于每一个新对象，ObjectBox 把比当前 box 中最大的 ID 值大的未使用的值指定给新对象的 ID.比如 box 中有一个 ID 为 1 和 ID 为 100 的对象，那么新创建对象的 ID 将为 101. 默认只有 ObjectBox 可以指定 ID(👇 介绍).如果试图自己存入一个 ID 比当前 ID 值最大的还大的对象，ObjectBox 将抛出错误。 手动指定 IDs如果需要手动指定 ID,那么请添加如下注解: 12@Id(assignable = true)long id; 这将会允许存入任意值 ID 的对象。当然设置 ID 为 0 时，ObjectBox 将制定新 ID 自定义 ID 会打破自动状态指示监视(new vs. persisted). 所以应该立即存入该自定义 ID 对象，可能还得手动绑定 box，特别在关联状况下. ID 的 String 别名 (还在路上…)查看特性实现进度String ID alias]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox高级-1-配置]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E9%AB%98%E7%BA%A7-1-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[手动添加依赖库如果 ObjectBox 插件没有自动添加依赖库和注解处理器，那么手动添加。 12345dependencies &#123; // all below should be added automatically by the plugin compile "io.objectbox:objectbox-android:$objectboxVersion" annotationProcessor "io.objectbox:objectbox-processor:$objectboxVersion"&#125; 1234567dependencies &#123; // all below should be added automatically by the plugin compile "io.objectbox:objectbox-android:$objectboxVersion" kapt "io.objectbox:objectbox-processor:$objectboxVersion" // some useful Kotlin extension functions compile "io.objectbox:objectbox-kotlin:$objectboxVersion"&#125; 改变 model 文件位置默认 model 文件位于 module-name/objectbox-models/default.json. 123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ "objectbox.modelPath" : "$projectDir/schemas/objectbox.json".toString() ] &#125; &#125; &#125;&#125; 12345kapt &#123; arguments &#123; arg("objectbox.modelPath", "$projectDir/schemas/objectbox.json") &#125;&#125; 改变 MyObjectBox 的包名默认 MyObjectBox 类包名和 entity 类或其父类的包名相同. 123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ "objectbox.myObjectBoxPackage" : "com.example.custom" ] &#125; &#125; &#125;&#125; 12345kapt &#123; arguments &#123; arg("objectbox.myObjectBoxPackage", "com.example.custom") &#125;&#125; 开启 debug 模式123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ 'objectbox.debug' : 'true' ] &#125; &#125; &#125;&#125; 12345kapt &#123; arguments &#123; arg("objectbox.debug", true) &#125;&#125; greenDAO 兼容查看greenDAO 兼容配置]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-12-事务]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E5%85%A5%E9%97%A8-12-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[ObjectBox 是一个满足 ACID 特性的交易型数据库.一个事务可以包含一组操作，要么执行成功，要么全部失败。几乎所有的 ObjectBox 的操作都包含了事务。比如 put(),read()。普通情况下，不用关心这些底层的事务。但某些复杂的情况下，手动处理事务操作可以使你的 app 更加高效一致。 手动事务ObjectBox 提供了如下方法实现手动事务： runInTx: 在事务中运行指定的 runnable runInReadTx: 在一个只读的事务中运行指定的 runnable.不同于写入事务，多个只读事务可以同时运行。 runInTxAsync: 在另一个线程中运行指定的 runnable.一旦事务执行完毕，callback(可为 null) 将被调用. callInTx: 类似 runInTx(Runnable),但是有返回值或抛出异常. 对批量存入操作进行手动事务的优势是你可以实现任意数量的操作，使用多个 box 对象。同时，在事务执行过程中，可以对数据有一个直观的认知。 1234567// 写入事务boxStore.runInTx(() -&gt; &#123; for (User user: allUsers) &#123; if (modify(user)) box.put(user); else box.remove(user); &#125;&#125;) 事务代价理解事务可以很好的帮助掌握数据库性能。请注意: 写入事务代价大.提交事务包含了将数据同步到物理存储中的操作，这对数据库是一个相对昂贵的操作。只有文件系统确认所有的数据都存储，事务操作才会被认为是成功的。事务同步该文件可能需要几毫秒。请记住：尽量把多个操作(put 等)放入同一个事务中. 12345678910// 不推荐for(User user: allUsers) &#123; modify(user); // modifies properties of given user box.put(user);&#125;// 推荐for(User user: allUsers) &#123; modify(user); // modifies properties of given user&#125;box.put(allUsers); 读取事务ObjectBox 的读取事务很快。相对于写入事务，没有 commit 操作，所以没有昂贵的同步文件系统。请注意：在一个读取事务中 put 操作是非法的，会抛出一个异常。get,count,queries 等操作没有手动声明事务(读写),默认会运行在一个读取事务.虽然读取事务比写入事务代价小，但是还是最好把它放入读取事务中。 多版本的并发ObjectBox 提供了语义化的多版本并发控制(Multiversion concurrency control MVCC).多个并发读取(读取事务)可以立即执行，无需阻塞或等待。这是通过存储多个版本的（提交）数据来实现的。即便一个写入事务正在运行，读取事务也可以立即获取到最新的同步状态。写入事务按顺序执行以便状态一致。所以保证写入事务短小可以避免阻塞其他写入事务。因此在一个写入事务中执行网络操作或复杂计算不推荐。尽量在写入事务前完成这些操作。 注意不需要自己手动维持写入事务序列。如果多线程想同时执行写入事务(put,runInTx),同一时刻只有一个线程可以执行，其他必须等待。类似 Java 中的 lock 或 synchronized。 深入写入事务尽量避免在写入事务中使用锁(synchronized 或 java.util.concurrent.locks).因为写入事务运行费时，所以 ObjectBox 内部会获取一个写入锁。当设计多个锁时，请提高警惕。始终以相同的顺序获取锁可以避免死锁。如果在一个事务获取了 X 锁，请保证你的代码在持有 X 锁时没有在另外一个写入事务中执行.]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-11-Data Browser]]></title>
    <url>%2F2019%2F02%2F26%2FObjectBox%E5%85%A5%E9%97%A8-11-Data-Browser%2F</url>
    <content type="text"><![CDATA[Data Browser 具有如下功能: 查看数据库的 entities 和 schema 下载 JSON 格式的 entities 配置1234567dependencies &#123; debugImplementation "io.objectbox:objectbox-android-objectbrowser:$objectboxVersion" releaseImplementation "io.objectbox:objectbox-android:$objectboxVersion"&#125;// apply the plugin after the dependencies blockapply plugin: 'io.objectbox' 不这样设置可能出现 Duplicate files copied in APK lib/armeabi-v7a/libobjectbox.so 这样的错误.因为 ObjectBox 插件又添加了一次 objectbox-android 库 在 AndroidManifest.xml 添加如下权限(2.2.0 后需要) 1234&lt;!-- Required to provide the web interface --&gt;&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;!-- Required to run keep-alive service when targeting API 28 or higher --&gt;&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE"/&gt; 建议在 Application 类中添加 12345boxStore = MyObjectBox.builder().androidContext(this).build();if (BuildConfig.DEBUG) &#123; boolean started = new AndroidObjectBrowser(boxStore).start(this); Log.i("ObjectBrowser", "Started: " + started);&#125;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-10-关联]]></title>
    <url>%2F2019%2F02%2F25%2FObjectBox%E5%85%A5%E9%97%A8-10-%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[Object 之间的关联具有方向性.关联是延迟初始化的：实际的引用对象只有在调用时才会从数据库中加载。一旦加载过，就会缓存起来. To-One 关联使用 ToOne 会智能的对目标对象创建关联。同时获取目标对象缓存。 12345678910111213141516// Customer.java@Entitypublic class Customer &#123; @Id public long id;&#125;// Order.java@Entitypublic class Order &#123; @Id public long id; public ToOne&lt;Customer&gt; customer;&#125;// 为了绑定 customer 对象，对 ToOne 实例调用 setTarget() 然后就存入 order 对象Customer customer = new Customer();Order order = new Order();order.customer.setTarget(customer);long orderId = boxStore.boxFor(Order.class).put(order); 如果 customer 在数据库中不存在，ToOne 将会存储。如果已经存在，那么 ToOne 只会创建关联,不会存储.如果关联 Entity 使用的是自定义 IDs(@Id(assignable = true)),则该 Entity 不会被存储. 在 ToOne 实例中，可通过 Order 对象的 getTarget() 获取 customer 12Order order = boxStore.boxFor(Order.class).get(orderId);Customer customer = order.customer.getTarget(customer); 如果只是想要获取 ID 而不是整个目标对象，getTargetId() 值得拥有，此方法根本不会接触数据库，所以高效。 移除关联: 仅移除关联关系，而不会从数据库中移除目标对象。 12order.customer.setTarget(null);boxStore.boxFor(Order.class).put(order); 查看 objectbox-models/default.json 会发现，ToOne 属性根本没有保存。仅仅只是目标对象的 ID 保存在一个名称和 ToOne 属性后拼接 Id 的虚拟属性. 初始化魔术注意到 ToOne 属性 customer 从没初始化，然而调用时却不会抛出空指针异常。因为该初始化已经执行过了。ObjectBox 插件会对 entity 类(仅支持纯 Java 项目和 Android 项目) 在调用前正确的初始化。所以在自定义构造方法时，你可以假设 ToOne/ToMany/List 属性已经初始化过了。 1234567891011121314@Entitypublic class Example &#123; ToOne&lt;Order&gt; order; ToMany&lt;Order&gt; orders; transient BoxStore __boxStore; public Example() &#123; // this.order = new ToOne&lt;&gt;(this, Example_.order); this.orders = new ToMany&lt;&gt;(this, Example_.orders); &#125; public Example(String value) &#123; this(); &#125;&#125; 提升性能为了提高性能，请提供全参数构造方法。对于 ToOne 属性，请添加一个名为 ToOne 属性名加 Id 的 id 参数。可以参考 objectbox-models/default.json 里的命名. 12345678910@Entitypublic class Order &#123; @Id public long id; public ToOne&lt;Customer&gt; customer; public Order() &#123; /* default constructor */ &#125; public Order(long id, long customerId /* virtual ToOne id property */) &#123; this.id = id; this.customer.setTargetId(customerId); &#125;&#125; ToMany 关联可以使用 List 或 ToMany 类型实现 ToMany 关联.相对 ToOne 来说，ToMany 可以实现追踪数据变化并将其写入操作中，而 List 必须自己实现. 1:N 使用 @Backlink 注解 1:N 关联属性。 123456789101112131415161718192021222324252627282930313233343536// Customer.java@Entitypublic class Customer &#123; @Id public long id; // 'to' is optional if only one relation matches @Backlink(to = "customer") public ToMany&lt;Order&gt; orders;&#125;// Order.java@Entitypublic class Order &#123; @Id public long id; public ToOne&lt;Customer&gt; customer;&#125;Customer customer = new Customer();customer.orders.add(new Order());customer.orders.add(new Order());long customerId = boxStore.boxFor(Customer.class).put(customer); // puts customer and ordersCustomer customer = boxStore.boxFor(Customer.class).get(customerId);for (Order order : customer.orders) &#123; // TODO&#125;Order order = customer.orders.remove(0);boxStore.boxFor(Customer.class).put(customer);// optional: also remove the order from its box// boxStore.boxFor(Order.class).remove(order); N:N 12345678910111213141516171819202122232425262728293031323334353637383940// Teacher.java@Entitypublic class Teacher&#123; @Id public long id;&#125;// Student.java@Entitypublic class Student&#123; @Id public long id; public ToMany&lt;Teacher&gt; teachers;&#125;Teacher teacher1 = new Teacher();Teacher teacher2 = new Teacher();Student student1 = new Student();student1.teachers.add(teacher1);student1.teachers.add(teacher2);Student student2 = new Student();student2.teachers.add(teacher2);// puts students and teachersboxStore.boxFor(Student.class).put(student1, student2);Student student1 = boxStore.boxFor(Student.class).get(student1.id);for (Teacher teacher : student1.teachers) &#123; // TODO&#125;student1.teachers.remove(0);// boxStore.boxFor(Student.class).put(student1);// more efficient than using put:student1.teachers.applyChangesToDb(); 上面可以通过 student 知道 teacher 的信息，当然可以反过来 1234567891011121314151617181920// Teacher.java@Entitypublic class Teacher&#123; @Id public long id; @Backlink(to = "teachers") // backed by the to-many relation in Student public ToMany&lt;Student&gt; students;&#125;// Student.java@Entitypublic class Student&#123; @Id public long id; public ToMany&lt;Teacher&gt; teachers;&#125; 更新关联ToOne 和 ToMany 可以追踪变化（只要存入拥有关联属性的 entity）并将其存入数据库中，如果 ID != 0 或者 @Id(assignable = true) 那么可以通过 Box 来更新关联 1234567// update a related entity using its boxOrder orderToUpdate = customer.orders.get(0);orderToUpdate.text = "Revised description";// DOES NOT WORK// boxStore.boxFor(Customer.class).put(customer);// WORKSboxStore.boxFor(Order.class).put(orderToUpdate); 更新 ToOneToOne 类提供了如下方法更新关联: setTarget(entity): 创建关联；传入 null 清除关联 setTargetId(entityId): 对存在的目标 entity 创建关联；传入 0 清除关联. setAndPutTarget(entity): 12order.customer.setTarget(customer); // or order.customer.setCustomerId(customer.getId());orderBox.put(order); 如果 entity 在调用 setAndPutTarget() 之前还没存储,那么需要先绑定它的 box 123Order order = new Order(); // new entityorderBox.attach(order); // need to attach box firstorder.customer.setAndPutTarget(customer); 如果目标 entity 使用自定义 IDs,必须在更新 ToOne 关联时存储它 1234customer.id = 12; // self-assigned idcustomerBox.put(customer); // need to put customer firstorder.customer.setTarget(customer); // or order.customer.setCustomerId(customer.getId());orderBox.put(order); 这是因为 ObjectBox 只保存 id 为 0 的关联对象. 更新 ToManyToMany 实现了 java.lang.List 接口。如果向 ToMany 实例添加对象，这些对象就会被存储进数据库。移除也一样。（仅仅是关联被移除而已）.不要忘记把追踪 ToMany 改变的 own entity 对象存储. 123customer.orders.add(order1);customer.orders.remove(order2);customerBox.put(customer); 如果使用自定义 IDs(@Id(assignable = true)) 请在修改 ToMany 前绑定它的 box 1234customer.id = 12; // self-assigned idcustomerBox.attach(customer); // need to attach box firstcustomer.orders.add(order);customerBox.put(customer); 如果 entity 是自定义 IDs,那么需要先存入该 entity,然后再更新关联并存储 own entity. 1234order.id = 42; // self-assigned idorderBox.put(order); // need to put order firstcustomer.orders.add(order);customerBox.put(customer); // put customer, add relation to order 树形关联可以使用 ToOne,ToMany 处理指向自身的树形关联 123456789@Entitypublic class TreeNode &#123; @Id long id; ToOne&lt;TreeNode&gt; parent; @BackLink ToMany&lt;TreeNode&gt; children;&#125; 生成的 entity 可以获取它的 parent 和 children 12TreeNode parent = entity.parent.getTarget();List&lt;TreeNode&gt; children = entity.children;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-9-订阅观察]]></title>
    <url>%2F2019%2F02%2F25%2FObjectBox%E5%85%A5%E9%97%A8-9-%E8%AE%A2%E9%98%85%E8%A7%82%E5%AF%9F%2F</url>
    <content type="text"><![CDATA[Data Observers, Reactive Extensions订阅观察模式，Rx 支持 1234Query&lt;Task&gt; query = taskBox.query().equal(Task_.complete,false).build();query.subscribe(subscriptions) .on(AndroidScheduler.mainThread()) .observer(data -&gt; updateUi(data)); Data Observers当数据改变时，ObjectBox 会通知所有的订阅者.他们可以订阅确定的数据类型(通过 BoxStore)或查询结果集。实现 io.objectbox.reactive.DataObserver 即可创建观察者 1234interface DataObserver&lt;T&gt; &#123; void onData(T data);&#125;| onData() 异步调用，不用关心线程 订阅普通改变123456DataObserver&lt;Class&lt;Task&gt;&gt; taskObserver = new DataObserver&lt;Class&lt;Task&gt;&gt;() &#123; @Override public void onData(Class&lt;Note&gt; data)&#123;&#125;&#125;;boxStore.subscribe(Task.class).observer(taskObserver);| subscribe() 会接受所有可用的对象类型改变通知。 订阅查询12Query&lt;Task&gt; query = taskBox.query().equal(Task_.completed, false).build();subscription = query.subscribe().observer(data -&gt; updateUi(data)); 取消订阅当调用 observer() 时，返回 io.objectbox.reactive.DataSubscription 1234interface DataSubscription &#123; void cancel(); boolean isCanceled();&#125; 1234DataSubscription subscription = boxStore.subscribe().observer(myObserver);// At some later point:subscription.cancel(); 通常情况下建议使用 DataSubscriptionList 123456789101112private DataSubscriptionList subscriptions = new DataSubscriptionList();protected void onStart() &#123; super.onStart(); Query&lt;X&gt; query = box.query()... .build(); query.subscribe(subscriptions)... .observe(...);&#125;protected void onStop() &#123; super.onStop(); subscriptions.cancel();&#125; 订阅，事务当事务提交时发出订阅通知。单独调用box.put(),remove() ，默认的事务会开启提交。例如如下将触发两次 User.class 通知； 12box.put(firendUser);box.put(myUser); 使用 runInTx(),callInTx() 可以将多个操作在同一个十五中提交.如上可以修改为: 1box.put(friendUser,myUser); 响应式扩展线程切换12Query&lt;Task&gt; query = taskBox.query().equal(Task_.complete, false).build();query.subscribe().on(AndroidScheduler.mainThread()).observer(data -&gt; updateUi(data)); 当然可以使用自定义 Looper 创建 AndroidScheduler,或者实现 io.objectbox.reactive.Scheduler 查询在后台线程执行 DataTransformer 运行在后台线程 DataObserver 和 ErrorObserver 运行在后台线程，除非通过 on() 指定 数据转换如何订阅实际的对象数量: 123boxStore.subscribe() .transform(clazz -&gt; return boxStore.boxFor(clazz).count()) .observer(count -&gt; updateCount(count)); 异常订阅transformer 可能抛出各种异常，DataObserver 可能抛出 RuntimeException. 123public interface ErrorObserver &#123; void onError(Throwable th);&#125; 在 subscribe() 后调用 onError() 即可. 一次通知 vs. 改变即通知当订阅 query 后，DataObserver 具有如下行为： 初始化查询结果(就在订阅后) 更新查询结果(在数据改变后) 有时候仅对其中一种行为感兴趣.single() 和 onlyChange() 应运而生(在 subscribe() 后调用)single() 只响应一次通知即自动取消。 弱引用一般情况下，为了避免内存泄露，通常尽可能在不需要的时候取消订阅。当然，你不在乎的话，在 subscribe() 后调用 weak() 也可以. ObjectBox RxJava 扩展库1implementation "io.objectbox:objectbox-rxjava:$objectboxVersion"]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-8-查询]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-8-%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[Queries 使用 QueryBuilder 定义查询标准，Query 类运行查询并返回匹配结果 QueryBuilder QueryBuilder 使用编译生成的元信息类来指定要匹配的属性值。 1234567List&lt;user&gt; joes = userBox.query().equal(User_.firstName,"Joe").build().find();QueryBuilder&lt;User&gt; builder = userBox.query();builder.equal(User_.firstName,"Joe") .greater(User_.yearOfBirth,1970) .startsWith(User_.lastName,"O");List&lt;User&gt; youngJoes = builder.build().find(); 边界条件 equal(),notEqual(),greater(),less() isNull(),notNull() between() in(),notIn() startsWith(),endsWith(),contains() and(),or() 排序1234567userBox.query().equal(User_.firstName,"Joe") .order(User_.lastName) // 升序排列,忽略大小写 .find();userBox.query().equal(User_.firstName,"Joe") .order(User_.lastName,QueryBuilder.DESCENDING | QueryBuilder.CASE_SENSITIVE) .find(); Query1234567Query&lt;User&gt; query = builder. build();// 返回所有匹配的对象List&lt;User&gt; joes = query.find();// 返回第一个匹配的对象，如果不存在返回 nullUser joe = query.findFirst();// 返回唯一一个匹配的对象，如果不存在返回 null,如果有多个值抛出异常User joe = query.findUnique(); 如果是不断的执行 Query,那么应该缓存 Query 对象，重复使用。为了复用 Query 对象，可以改变它的属性值，或查询参数，或添加的各种边界条件。 12345// 假设已经构建了一个 Query 对象，但是为了后面复用，此处 equal 边界条件的值设置为 ""Query&lt;User&gt; query = userBox.query().equal(User_.firstName,"").build();// 接下来可以根据具体情况改变参数值List&lt;User&gt; joes = query.setParameter(User_.firstName,"Joe").find();List&lt;User&gt; jakes = query.setParameter(User_.firstName,"Jake").find(); 如果是多个边界条件，可以在边界条件后给每一个参数设置一个别名 1234// 给 equal() 查询参数设置 name 别名Query&lt;User&gt; query = userBox.query().equal(User_.firstName,"").parameterAlias("name");// 然后可以传入键值对来代替属性List&lt;User&gt; joes = query.setParameter("name","Joe").find(); Limit,Offset,Pagination12Query&lt;User&gt; query = userBox.query().equal(User_.firstName,"Joe").build();List&lt;User&gt; joes = query.find(/*offset*/10,/*limit*/5,/*results*/); 延迟加载 findLazy(),findLazyCached() 返回 LazyList 查询结果。 LazyList 是线程安全的，不可修改的只读 list,只有在访问时才会加载数据。缓存 LazyList 可以保留之前访问过的数据以避免重复加载。 删除query.remove() 删除所有匹配的结果 属性查询如果只想返回某个指定属性的值而不是匹配的全部对象列表，那么请使用 PropertyQuery.在构建 query 后调用 property(Property) 即可 123String[] emails = userBox.query().build() .property(User_.mail) .findStrings(); findString() 返回第一条结果，findStrings() 返回所有结果 返回的是没有排序的结果，即使在构建 query 时指定了排序规则. 处理 null 值默认不返回 null 值。如果属性为 null，可以指定一个替代返回值 12345// 如果 email 为 null,返回 unknownString[] emails = userBox.query() .property(UserBox_.mail) .nullValue("unknown") .findStrings(); distinct，unique12345// 返回 ‘joe'String[] names = userBox.query() .property(User_.firstName) .distinct() .findStrings(); 默认 strings 忽略大小写。当然可以定制 12345// 返回 'joe' 'Joe' 'JOE'String[] names = userBox.query() .property(User_.firstName) .distinct(StringOrder.CASE_SENSITIVE) .findStrings(); 只查询一个值，没有则抛出异常 1234String[] names = userBox.query().build().equal(User_.isAdmin, true) .property(User_.firstName) .unique() .findStrings(); distinct 和 unique 可以组合 统计属性查询同时提供了统计函数。 min(),minDouble() max(),maxDouble() sum,sumDouble(): sum() 可能溢出并抛出异常 avg(): 返回 double count(): 比查询到对象列表然后求列表长度要快。可以和 distinct() 组合 为关联属性添加查询条件创建关联属性后，可能想为只存在于关联 entity 的属性添加查询条件。SQL 中使用 JOIN. 12345678910111213@Entityclass Person &#123; @Id var id: Long = 0 var name: String? = null lateinit var address: ToManay&lt;Address&gt;&#125;@Entityclass Address &#123; @Id var id: Long = 0 var street: String? = null var zip: String? = null&#125; 查询住在指定街道(Address)的 xxx(Person)。可以使用link(RelationInfo 12345// 获取所有名为 elmo 的对象val builder = box.query().equal(Person_.name,"Elmo");// 住在 Sesame 街道builder.link(Person_.address).equal(Address_.street,"Sesame Street");val elmosOnSesameStreet = builder.build().find() 如果想获取到 Address 列表呢？那么可以在 Address 中添加 @Backlint 注解 1234567891011@Entityclass Address &#123; // ... @Backlint(to = "addresses") lateinit var persons: ToMany&lt;Person&gt;&#125;// 获取所有 Sesame 街道对象val builder = box.query().equal(Address_.street,"Sesame Street");// 名为 elmobuilder.link(Address_.persons).equal(Person_.name,"Elmo");val sesameStreetsWithElmo = builder.build().find(); 当然，也可以不用修改 Address,使用 backlink(RelationInfo) 即可实现查询 123val builder = box.query().equal(Address_.street,"Sesame Street");builder.backlink(Person_.address).equal(Person_.name,"Elmo");val sesameStreetWithElmos = builder.build().find(); 关系属性的激进加载默认关系属性是懒加载的。第一次访问 ToOne ,ToMany 属性时会到数据库中查询数据，然后都会使用缓存过的数据。 12val customers = customerBox.query().build().find()customers[0].orders[0]; // 第一次访问触发数据库查询 如果想在查询结果返回时实现预读取 ToOne,ToMany 数据,请使用 QueryBuilder.eager 1234val customers = customerBox.query() .eager(Customer_.orders) .build() .find(); eager 加载仅支持一层深度。如果有嵌套的关联层级，可以使用下面的 query filter 实现。 query filters应用于复杂的边界条件，QueryBuilder 类不能实现。使用如下规则将会非常高效： 使用标准的数据库边界条件缩小目标范围。(使用 QueryBuilder 获取目标) 然后使用 QueryFilter 过滤QueryFilter 一次检查一个目标对象，符合返回 true 12345// 缩小范围songBox.query().equal(Song_.bandId,bandId) .filter((song) -&gt; &#123; return song.starCount * 2 &gt; song.downloads; &#125;); 关注一下性能: ObjectBox 创建对象非常快 虚拟机会回收短期对象。此处回收将比创建快，所以性能不是问题。 query filters 和 ToManyToMany 提供了很多函数可以方便的转为 query filters: hasA hasAll getById]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-7-kotlin支持]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-7-kotlin%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Kotlin 支持kotlin Entity 在 kotlin 中，ID 属性应该这样定义 @Id var id: Long = 0.ID 必须是 var. 构造器 ObjectBox 优先调用全参的构造方法。如果自定义属性或 transient 属性 或关联属性是构造方法的一部分参数，ObjectBox 将不会调用此构造方法.所以应该提供为这些参数提供默认值以确保无参构造方法存在。 1234567@Entitydata class Note( @Id var id: Long = 0, val text: String = "", @Convert( converter = StringsConverter::class, dbType = String::class) val strings: List&lt;String&gt; = listOf()) kotlin Entity 中定义关联属性在 kotlin 中定义关联属性可能比较麻烦。但请注意：关联属性必须为 var. 否则 initialization magic 将不起作用.通常可以使用 lateinit 修饰关联属性 123456789101112@Entityclass Order &#123; @Id var id: Long = 0 lateinit var customer: ToOne&lt;Customer&gt;&#125;@Entityclass Customer &#123; @Id var id: Long = 0 @Backlink( to = "customer") latelinit var orders: List&lt;Order&gt;&#125; kotlin 扩展函数123dependencies &#123; implementation "io.objectbox:objectbox-kotlin:$objectboxVersion"&#125; kotlin 12345678910111213val box: Box&lt;DataClassEntity&gt; = store.boxFor()val query = box.query &#123; equal(property,value) order(property)&#125;val query = box.query().inValues(property,array).build()toMany.applyChangesToDb(resetFirst = true) &#123; // 默认 false add(entity) removeById(id)&#125;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-6-Java桌面应用.md]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-6-Java%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java 桌面应用嵌入式数据库ObjectBox 不仅仅适用于 Android 项目，同时也适用于运行在 Windows Linux macOS 上的纯 Java(JVM) 桌面应用. 配置请使用 Gradle 作为构建工具，因为 ObjectBox 使用了 Gradle 插件. 1234567891011121314151617buildscript &#123; ext.objectboxVersion = '2.3.3' repositories &#123; jcenter() maven&#123; url "https://plugins.gradle.org/m2/"&#125; &#125; dependencies &#123; classpath "net.ltgt.gradle:gradle-apt-plugin:0.20" classpath "io.objectbox:objectbox-gradle-plugin:$objectboxVersion" &#125;&#125;repositories &#123; jcenter()&#125;apply plugin: 'java'apply plugin: 'net.ltgt.apt-idea' // 注解处理器插件apply plugin: 'io.objectbox' Native 库ObjectBox 是由 C/C++写成的可以运行大多数 native code 的对象数据库。 改变 Model 文件位置默认 model 文件存储在 module-name/objectbox-models/default.json.可以通过修改 objectbox.modelPath 来改变 1234// 在项目 build.gradle 文件， apply plugin: 'java' 之后添加tasks.withType(JavaCompile) &#123; options.compilerArgs += ["-Aobjectbox.modelPath=$projectDir/schemas/object.json]&#125; 改变 MyObjectBox 包名123tasks.withType(JavaCompile) &#123; options.compilerArgs += [ "-Aobjectbox.modelPath=$projectDir/schemas/objectbox.json" ]&#125; 开启 debug 模式12345678// enable debug output for pluginobjectbox &#123; debug true&#125;// enable debug output for annotation processortasks.withType(JavaCompile) &#123; options.compilerArgs += [ "-Aobjectbox.debug=true" ]&#125; 可以使用 BoxStore builder 的 name(String) 来改变数据库存储的位置。单元测试添加 junit 4 库]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-5-LiveData]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-5-LiveData%2F</url>
    <content type="text"><![CDATA[LiveData (Arch.Comp.)从 1.2.0 开始支持 Android Architecture ComponentsObjectBox 提供 ObjectBoxLiveData 可以在 ViewModel 中使用 1234567891011public class NoteViewModel extends ViewModel &#123; private ObjectBoxLiveData&lt;Note&gt; noteLiveData; public ObjectBoxLiveData&lt;Note&gt; getNoteLiveData(Box&lt;Note&gt; notesBox) &#123; if (noteLiveData == null) &#123; // 查询所有的 notes, text 按 a-z 的顺序排列 noteLiveData = new ObjectBoxLiveData(notesBox.query().order(Note_.text).build()); &#125; return noteLiveData; &#125;&#125; 上一种方法需要传入 Box.可以使用 AndroidViewModel 代替，它可以访问 Application context,然后会在 ViewModel 中调用 ((App)getApplication()).getBoxStore().boxFor().第一种的优势在于没有引用 Android 类，所以可以进行单元测试。 1234567NoteViewModel model = ViewModelProviders.of(this).get(NoteViewModel.class);model.getNoteLiveData(notesBox).observe(this,new Observer&lt;List&lt;Note&gt;&gt;&#123; @Override public void onChanged(@Nullable List&lt;Node&gt; notes) &#123; notesAdapter.setNotes(notes); &#125;&#125;) Paging (Arch.Comp.)从 2.0.0 开始支持.ObjectBox 提供了 ObjectBoxDataSource 类.它继承了 paging 库的 PositionalDataSource在 ViewModel 中，类似创建 LiveData,先创建 ObjectBox query.然后构造并使用 ObjectBoxDataSource 工厂代替 LiveData. 1234567891011121314public class NotePageViewModel extends ViewModel &#123; private LiveData&lt;PagedList&lt;Note&gt;&gt; noteLiveDataPaged; public LiveData&lt;PagedList&lt;Note&gt;&gt; getNoteLiveDataPaged(Box&lt;Note&gt; notesBox) &#123; if(noteLiveDataPaged == null) &#123; Query&lt;Note&gt; query = notesBox.query().order(Note_.text).build(); noteLiveDataPaged = new LivePagedListBuilder( new ObjectBoxDataSource.Factory(query), 20 // 页数 ).build(); &#125; return noteLiveDataPaged; &#125;&#125;]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-4-本地单元测试]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-4-%E6%9C%AC%E5%9C%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[安卓本地单元测试设置测试环境| 此配置仅针对 ObjectBox 1.4 及之前版本.新版本已经自动添加了 native ObjectBox 依赖库。 123456789// /app/build.gradledepdendencies &#123; // 必备 JUnit 4 testImplementation 'junit:unit:4.12' // 手动添加平台独立的 native Objectbox 依赖库.(可选) testImplementation "io.objectbox:objectbox-linux:$objectboxVersion" testImplementation "io.objectbox:objectbox-macos:$objectboxVersion" testImplementation "io.objectbox:objectbox-windows:$objectboxVersion"&#125; | 本地单元测试仅支持 64 位系统.| windows 可能需要安装 Microsoft Visual C++ 2015 Redistributable(x64) 创建本地单元测试类 可以使用 BoxStore builder 的directory(File) 指定数据库保存在本地设备上。 为保证数据不交叉污染，可以使用 BoxStore.deleteAllFiles(File) 删除已经存在的数据库 12345678910111213141516171819202122232425262728293031public class NoteTest &#123; private static final File TEST_DIR = new File("objectbox-example/test-db"); private BoxStore store; @Before public void setUp() throws Exception &#123; // 删除之前的数据库 BoxStore.deleteAllFiles(TEST_DIR); store = MyObjectBox.builder() // 指定数据库存放路径 .directory(TEST_DIR) // 添加 debug 标记打印日志 .debugFlags(DebugFlags.LOG_QUERIES | DebugFlags.LOG_QUERY_PARAMETERS) .build(); &#125; @After public void tearDown() throws Exception &#123; if (store != null) &#123; store.close(); store = null &#125; BoxStore.deleteAllFiles(TEST_DIR); &#125; @Test public void exampleTest() &#123; Box&lt;Note&gt; noteBox = store.boxFor(Note.class); assertEquals(...); &#125;&#125; 关系测试 ObjectBox 1.4.4 及之后 为了测试具有 ToOne,ToMany 属性的 entity,必须在本地 JVM 初始化 entity 并且添加一个 transient 的 BoxStore 属性.]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-3-注解]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-3-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Entity 注解entity 数据可访问 ObjectBox 需要访问 entity 的属性(生成 Cursor 类). 属性包内可见。kotlin 中使用 JvmField 提供标准 getters 为了提升性能，请提供具有全部属性的构造方法 123456789101112@Entitypublic class User &#123; @Id private long id; private String name; @Transient private int tempUsageCount; public User()&#123;/* 默认构造方法 */&#125; public User(id,name)&#123; this.id = id; this.name = name; &#125; // getters and setters for properties...&#125; entity 属性的注解 @NameInDb 可以在数据库中为属性命名。 应该使用 @Uid 注解来代替重命名属性和 entity @NameInDb 仅支持内联常量来指定列名。 @Transient 保证属性不被持久化，transient，static 修饰符也一样. 属性索引 @Index @Index 当前不支持 byte[] float double Index typs(String). ObjectBox 2.0 引入了 index types.之前对每一个索引，使用属性的值来完成查询。现在 ObjectBox 可以使用 hash 来生成 index.由于 String 属性明显比标量值更占空间，ObjectBox 对 strings 使用默认的 index type 完成 hash.可以针对 String 类型的属性明确指定 index type 为基于值构建索引。 12@Index( type = IndexType.VALUE)private String name; 请注意：对于 String 类型的属性，基于值的索引可能比默认基于 hash 的索引更占空间,这种结论取决于该值的长度。 ObjectBox 支持以下索引属性: 未指定或默认: 根据属性的类型决定(HASH for String,VALUE for others) VALUE: 使用属性值生成索引。例如 String,可能更占空间 HASH: 使用属性值的 32 位 hash 生成索引。偶尔可能发生 hash 碰撞，但实际概率很小。通常比 HASH64 更佳，因为占空间小 HASH64: 使用属性值的长 hash 生成索引。比 HASH 占空间大，所以一般情况下不是首选. Unique 约束如果 unique 约束的属性值冲突，put() 操作将被终止且抛出 UniqueViolationException 的异常.Unique 基于 Index,所以可以同时给属性添加 @Index 注解。 关系]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-2-基本操作]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-2-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Entity在一个类中至少需要 @Entity 和 @Id 两个注解才能定义一个 ObjectBox model.例如: 123456// User.java@Entitypublic class User &#123; @Id public long id; public String name;&#125; 然后 make 就可生成 model. | @Id 的类型必须为 long.| 如果 entity 发生了很大的变动（如移动类或修改注解）,必须 rebuild 项目以便 ObjectBox 生成的代码得到更新. 核心类 MyObjectBox: 基于 entity 类生成。提供 builder 配置 BoxStore. BoxStore: ObjectBox 的入口。操作数据库，管理 Boxes 的工具. Box: 对 entity 保存和查询。每一个 entity 都有一个对应的 Box（由 BoxStore 提供). 核心初始化实例化 BoxStore 的最好时机是在 app 启动时。推荐在 Application 类的 onCreate 方法中进行. 12345678910111213public class App extends Application &#123; private BoxStore boxStore; @Override public void onCreate() &#123; super.onCreate(); boxStore = MyObjectBox.builder().androidContext(this).build(); &#125; public BoxStore getBoxStore() &#123; return boxStore; &#125;&#125;// 然后在 app 生命周期内就可以使用了notesBox = ((App) getApplicationi()).getBoxStore().boxFor(User.class); Box 基本操作 put: 存入一个对象，可能会覆盖具有相同 ID 的对象。即使用 put 插入或更新对象。返回 ID。 get,getAll: 提供一个对象的 ID，可快速的通过 get获取它。getAll 获取指定的所有的对象。 remove,removeAll: 从 box 中删除一个对象。removeAll 删除指定的所有对象. count: 返回该 box 存储的对象数量. query: 返回一个 query builder. Object IDs Entity 必须具有一个类型为 long,由 @Id 注解属性。当然可以使用可空的 java.lang.Long类型，但不推荐。如果需要使用另外一种类型的 ID(服务器返回的 String 类型的 UID),把它作为普通属性即可，然后可以通过此 ID 查询. 123456@Entity class StringIdEntity &#123; @Id priavte long id; private String uid;&#125;StringIdEntity entity = box.query().equal(StringIdEntity_.uid,uid).findUnique(); 指定 IDObjectBox 默认会为新对象指定 IDs.ID 自增. 12345User user = new User();// user.id == 0box.put(user);// user.id != 0long id = user.id 如果插入的对象的 ID 比 box 里的 ID 最大值还大，ObjectBox 将抛出错误. 保留 Object IDsObject IDs 不能：– 0,null(使用 java.lang.Long)。– 0xFFFFFFFFFFFFFFFF（java 中的 -1）:内部保留 事务 put 运行在隐式事务中 优先使用 put 批量操作列表 （put(entities)） 如果在循环中操作大量数据，考虑明确使用事务，如runInTx()]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ObjectBox入门-1-简介]]></title>
    <url>%2F2019%2F02%2F24%2FObjectBox%E5%85%A5%E9%97%A8-1-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[关于ObjectBox 定位是: 针对移动端和 IoT 超快的 (superfast edge database) 面向对象的数据库 .为小型设备提供了边缘计算能力，使得数据可以快速高效地在本地存储、处理、安全管理.ObjectBox 小于 1MB,最适合移动 APP、小型 IoT 设备及路由。并且 ObjectBox 也是第一个在边缘设备上兼容 ACID 的高性能的 NoSQL 数据库.所有的产品都是基于工程师思维开发的，所以可以使用最少的代码去实现想要的功能。 优点 比同类竟品快 10 倍以上。BenchMark 跨平台。支持 Linux、Windows、Mac/iOS、Android、Raspberry Pi、ARM 等嵌入式设备和容器。 小于 1MB,特别针对小型设备设计和优化。 易使用。 支持 reactive. 无缝结合 greenDAO.(同一家公司出品) 更好地支持关系型数据. 提供了改变追踪(change tracking)，级联添加(cascading puts)，灵活的加载策略(eager,lazy) 无需掌握 SQL:ObjectBox 设计简单，使用方便，不需要掌握 SQL 即可上手. 支持 kotlin: 包括 data class. 使用Android(Java)123456789101112// root 目录 build.gradlebuildscript &#123; ext.objectboxVersion = '2.3.3' repositories &#123; jcenter() &#125; dependencies &#123; // Android Gradle plugin 最低版本为 3.0.0 classpath 'com.android.tools.build:gradle:3.3.1' classpath "io.objectbox:objectbox-gradle-plugin:$objectboxVersion" &#125;&#125; 123// app 或其他 module build.gradleapply plugin: 'com.android.application'apply plugin: 'io.objectbox' 放在最下面 Android(Kotlin)12345// app 或其他 module build.gradleapply plugin: 'com.android.application'apply plugin: 'kotlin-android'apply plugin: 'kotlin-kapt' 如果使用 kotlin-android 插件，必须加 kotlin -kapt 插件apply plugin: 'io.objectbox' 放在最下面 Sync gradle 即可自动添加 ObjectBox 依赖. 配置1、首先添加 ObjectBox 插件.2、如果 ObjectBox 插件没有自动添加依赖库和注解处理器，请手动添加依赖。 123456// Android(Java)// /app/build.gradledependencies &#123; compile "io.objectbox:objectbox-androoid:$objectboxVersion" annotationProcessor "io.objectbox:objectbox-processor:$objectboxVersion"&#125; 12345678// Android(kotlin)// /app/build.gradledependencies &#123; compile "io.objectbox:objectbox-android:$objectboxVersion" kapt "io.objectbox:objectbox-processor:$objectboxVersioni" // 针对 kotlin 的扩展函数(可选) compile "io.objectbox:objectbox-kotlin:$objectboxVersion"&#125; 3、改变 Model 文件的路径 ObjectBox Model 文件默认保存在 module-name/objectbox-models/default.json。 1234567891011// Android(Java)// /app/build.gradleandroid &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = ["objectbox.modelPath":"$projectDir/schemas/objectbox.json".toString()] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app/build.gradlekapt &#123; arguments &#123; arg("objectbox.modelPath":"$projectDir/schemas/objectbox.json") &#125;&#125; 4、改变 MyObjectBox 的包名 MyObjectBox 类的包名默认和 entitiy 类的包名或其上一级报名一致。 1234567891011// Android(Java)// /app/build.gradleandroid &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = ["objectbox.myObjectBoxPackage":"com.example.custom"] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app/build.gradlekapt &#123; arguments &#123; arg("objectbox.myObjectBoxPackage", "com.example.custom") &#125;&#125; 5、开启 Debug 模式 在 /app/build.gradle 中添加必要的选项后，运行 ./gradlew --info 即可查看 debug 输出 1234567891011// Android(Java)// /app/build.gradleandroid &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = ['objectbox.debug' : 'true'] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app/build.gradlekapt &#123; arguments &#123; arg("objectbox.debug", true) &#125;&#125; 6、开启 DaoCompat 兼容模式 从 greenDAO 迁移过来，生成和 greenDAO 相似的 API,使 ObjectBox 看起来就像 SQLite 一样。 1234// /app[module]/build.gradledepdendencies &#123; compile "org.greenrobot:objectbox-daocompat:1.10"&#125; 然后开启 DaoCompat 模式 1234567891011// Android(Java)// /app[module]/build.gradleandroid &#123; defaultConfig &#123; javaCOmpileOptions &#123; annotationProcessorOptions &#123; arguments = ['objectbox.daoCompat':'true'] &#125; &#125; &#125;&#125; 1234567// Android(Kotlin)// /app[module]/build.gradlekapt &#123; arguments &#123; arg("objectbox.daoCompat":true) &#125;&#125; 如果你计划从 greenDAO 迁移到 ObjectBox,那么你可能会保留原来的 greenDAO entity 类（复制这些类到另外的包中）然后按如下修改。 首先改变注解。请注意：不是所有的 greenDAO 注解都支持无缝迁移到 ObjectBox,支持的如下： 1234567// greenDAOimport org.greenrobot.greendao.annotation.Entity;import org.greenrobot.greendao.annotation...// ObjectBoximport io.objectbox.annotation.Entity;import io.objectbox.annotation... ObjectBox 当前不支持 unique indexes,naming indexes,或者在多个属性间 indexes. 1234567// greenDAO@Entity(indexes = ...)@Index(name = "idx1", unique = true) private String name;@Unqiue private String name;// ObjectBox@Index private String name; 自定义类型。修改父类,当然也可同时继承，这样该自定义类型就可同时在 greenDAO 和 ObjectBox 间使用 12345// greenDAOimport org.greenrobot.greendao.converter.PropertyConverter;// ObjectBoximport io.objectbox.converter.PropertyConverter; 修改 @Convert 注解里的 columnType 改为 dbType 12345// greenDAO@Convert(converter = NoteTypeConverter.class, columnType = String.class)// ObjectBox@Convert(converter = NoteTypeConverter.class, dbType = String.class) 关系。ObjectBox 使用 ToOne 和 ToMany类型替代 greenDAO 的 @ToOne 和 @ToMany 注解。 使用 BoxStore.修改完 entity 后，设置 BoxStore 创建 DaoSession. 123456789// 通常在 Application 类中boxStore = MyObjectBox.builder().androidContext(this).build();daoCompatSession = new DaoSession(boxStore);// 在迁移完成后，你可能想移除这些迁移操作。// 那么通过 greenDAO session 获取 entities,把他们转为 ObjectBox entities,// 然后使用 DaoCompat session 插入。List&lt;com.example.app.daos.greendao.Note&gt; notes = daoSession.getNoteDao().loadAll();List&lt;Note&gt; convertedNotes = convertToObjectBoxNotes(notes);daoCompatSession.getNoteDao().insertInTx(convertedNotes); 默认没有设置 ID (即 id == 0),ObjectBox 会为插入的数据生成一个新的 ID.如果想保留原来的 ID,请修改 @Id(assignable = true) 使用 DaoCompat DaoSession在使用新 compat session 替换原来的 API 后，可以通过在 Application 类中的一个方法返回 DaoSession 123456public DaoSession getDaoSession() &#123; // greenDAO // return daoSession; // ObjectBox return daoCompatSession;&#125; 表面上 compat DaoSession 是 greenDAO DaoSession 的替代品，其实它内部是使用 BoxStore 代替了 greenDAO 数据库.如果还使用了 greenDAO 的额外特性，比如 queries,那么还需如下修改: 123456// greenDAOimport org.greenrobot.greendao.query.Query;import org.greenrobot.greendao...// ObjectBoximport org.greenrobot.daocompat.query.Query;import org.greenrobot.daocompat... QueriesDaoCompat 支持以下的 Query 功能:– remove() 替代 DeleteQuery– count() 替代 CountQuery– 不支持 CursorQuery DaoCompat 和 greenDAO 的不同– 不支持 NotNull– 不支持 Joins 和 原生 SQL 查询.– 不支持异步 sessions: startAsyncSession()– 不支持加密– 仅支持简单的 AbstractDaoTest 和 AbstractDaoBasicTest]]></content>
      <tags>
        <tag>ObjectBox</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 笔记]]></title>
    <url>%2F2018%2F03%2F17%2Fgit-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[config 1234567891011121314151617181920212223242526272829303132333435363738# 修改配置git config --local # 对某个仓库有效git config --global # 对当前用户所有仓库有效git config --system # 对系统所有登录用户有效# 查看配置git config --list --localgit config --list --globalgit config --list --system# 打开编辑器修改configgit config -e # 仅对当前仓库有效# 变更文件名git mv readme readme.md # 避免 mv x y -&gt; git add -&gt; git rmgit log [分支] --oneline # 一行显示 -n4 # 指定最新的几次提交 --all # 所有分支的提交 --graph # 图形化显示# 打开内置帮助网页.git help --web [log]# guigitk --allgit branch -av# 在 ./git/refs/heads/xxx 中查看信息git cat-file -t master # 返回 git object model 类型: blog, tree, commit, tag -p # 显示所有内容# 删除分支git branch -D [fixup]# 变基git rebase -i# 暂存区和最近一次提交的区别git diff --cached# 将暂存区的内容丢弃git reset HEAD -- &lt;file&gt;# 将暂存区的内容恢复到本地git checkout -- &lt;file&gt;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
